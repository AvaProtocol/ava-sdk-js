name: Run Dev Tests on PR

on:
  pull_request:
  workflow_dispatch:
    inputs:
      docker_image_tag:
        description: "Docker Image Tag of avaprotocol/avs-dev"
        required: false
        default: "latest" # Or use an empty default if you want to force it from elsewhere for PRs

jobs:
  dev-test:
    runs-on: ubuntu-latest
    environment: dev

    env:
      CHAIN_ENDPOINT: ${{ vars.CHAIN_ENDPOINT }}  # Should be: ethereum-sepolia.core.chainstack.com/2504cb0765f0edf6c33d99095148006f
      TEST_PRIVATE_KEY: ${{ secrets.TEST_PRIVATE_KEY }}
      TEST_ENV: "dev"
      DOCKER_IMAGE_TAG: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.docker_image_tag || 'latest' }} # Or your preferred default for PRs
      
      # Aggregator configuration (mapped from your GitHub settings)
      ECDSA_PRIVATE_KEY: ${{ secrets.ECDSA_PRIVATE_KEY }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      TENDERLY_ACCESS_KEY: ${{ secrets.TENDERLY_ACCESS_KEY }}
      CONTROLLER_PRIVATE_KEY: ${{ secrets.CONTROLLER_PRIVATE_KEY }}
      AP_NOTIFY_BOT_TOKEN: ${{ secrets.AP_NOTIFY_BOT_TOKEN }}
      MORALIS_API_KEY: ${{ secrets.MORALIS_API_KEY }}
      
      # From repository variables
      SENTRY_DSN: ${{ vars.SENTRY_DSN }}
      TENDERLY_ACCOUNT: ${{ vars.TENDERLY_ACCOUNT }}
      TENDERLY_PROJECT: ${{ vars.TENDERLY_PROJECT }}
      THEGRAPH_API_KEY: ${{ vars.THEGRAPH_API_KEY }}
      SENDGRID_KEY: ${{ vars.SENDGRID_KEY }}
      
      # From dev environment variables
      BUNDLER_URL: ${{ vars.BUNDLER_URL }}
      AVS_API_KEY: ${{ secrets.AVS_API_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Debug environment variables
        run: |
          echo "DOCKER_IMAGE_TAG: $DOCKER_IMAGE_TAG"
          echo "CHAIN_ENDPOINT: $CHAIN_ENDPOINT"
          echo "TEST_ENV: $TEST_ENV"
          echo "AVS_API_KEY length: ${#AVS_API_KEY}"
          echo "JWT_SECRET length: ${#JWT_SECRET}"
          echo "ECDSA_PRIVATE_KEY length: ${#ECDSA_PRIVATE_KEY}"
          echo "BUNDLER_URL: $BUNDLER_URL"
          echo "TENDERLY_ACCESS_KEY length: ${#TENDERLY_ACCESS_KEY}"

      - name: Check Source or Test Code Changes
        id: check_source_changes
        if: github.event_name == 'pull_request'
        run: |
          echo "PR Base SHA: ${{ github.event.pull_request.base.sha }}"
          echo "PR Head SHA: ${{ github.event.pull_request.head.sha }}"
          echo "GitHub Ref: ${{ github.ref }}"

          # Ensure we have the base branch
          git fetch origin ${{ github.base_ref }} --depth=1

          # Get all changed files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }} HEAD)

          # Define the source code patterns we want to monitor
          SOURCE_PATTERN='^(packages/sdk-js/src|packages/types/src|tests/)'

          echo "=== Debug Information ==="
          echo "Base ref: ${{ github.base_ref }}"
          echo "Current branch: $(git branch --show-current)"
          echo "Git status:"
          git status

          echo "=== Changed Files ==="
          echo "$CHANGED_FILES"

          # Check if any files in our monitored directories have changed
          MATCHING_FILES=$(echo "$CHANGED_FILES" | grep -E "$SOURCE_PATTERN" || echo "")

          echo "=== Matching Files ==="
          echo "$MATCHING_FILES"

          if [ -z "$MATCHING_FILES" ]; then
            echo "source_changed=false" >> $GITHUB_OUTPUT
            echo "No changes detected in monitored directories, skipping tests"
          else
            echo "source_changed=true" >> $GITHUB_OUTPUT
            echo "Changes detected in monitored directories:"
            echo "$MATCHING_FILES"
          fi
        shell: bash

      - name: Inject secrets into aggregator config
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: |
          echo "Injecting secrets into aggregator configuration..."
          echo "Chain endpoint: ${CHAIN_ENDPOINT}"
          echo "Test environment: ${TEST_ENV}"
          
          # Use envsubst to replace ${VAR} placeholders with actual environment variables
          envsubst < config/aggregator.yaml > config/aggregator.runtime.yaml
          
        # Verify the config was generated (without showing secrets)
        echo "Generated config file size: $(wc -l < config/aggregator.runtime.yaml) lines"
        echo "Config template placeholders replaced successfully"
        echo ""
        echo "=== Generated config structure (masking secrets) ==="
        sed 's/eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*/[JWT_TOKEN_MASKED]/g; s/0x[a-fA-F0-9]\{64\}/[PRIVATE_KEY_MASKED]/g; s/SG\.[A-Za-z0-9_-]*/[SENDGRID_KEY_MASKED]/g' config/aggregator.runtime.yaml

      - name: Run local AVS aggregator in Docker
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: |
          echo "Starting AVS aggregator with version: $DOCKER_IMAGE_TAG"
          docker compose up -d
          
          echo "Waiting for aggregator to start..."
          sleep 10
          
          echo "=== Aggregator container status ==="
          docker compose ps
          
          echo "=== Aggregator logs (last 50 lines) ==="
          docker compose logs aggregator --tail=50

      - name: Use Node.js
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "yarn"

      - name: Install dependencies
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: yarn install

      - name: Ensure the aggregator is running
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: |
          echo "Waiting for aggregator to become ready..."
          max_attempts=24  # 2 minutes total (24 * 5 seconds)
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            echo "Attempt $((attempt + 1))/$max_attempts: Testing aggregator health..."
            
            # Test if aggregator responds
            if curl --output /dev/null --silent --fail --max-time 5 http://localhost:1323/up; then
              echo "✅ Aggregator is ready!"
              curl -v http://localhost:1323/up
              break
            else
              echo "❌ Aggregator not ready yet..."
              echo "Container status:"
              docker compose ps
              echo "Recent aggregator logs:"
              docker compose logs aggregator --tail=10
              echo "Waiting 5 seconds..."
              sleep 5
            fi
            
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "🚨 Aggregator failed to start after $((max_attempts * 5)) seconds"
            echo "Final container status:"
            docker compose ps
            echo "Full aggregator logs:"
            docker compose logs aggregator
            exit 1
          fi

      - name: Retrieve AVS API Key from the aggregator
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        id: setup-env
        run: |
          echo "AVS_API_KEY=$(docker compose exec aggregator /ava create-api-key --role=admin --subject=apikey)" >> $GITHUB_ENV

      - name: Print Required Environment Variables
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: |
          echo "=== Required Variables from envalid.ts ==="
          echo "AVS_API_KEY: ...${AVS_API_KEY: -6}" # Show last 6 chars for security
          echo "CHAIN_ENDPOINT: $CHAIN_ENDPOINT"
          echo "TEST_PRIVATE_KEY: ...${TEST_PRIVATE_KEY: -6}" # Show last 6 chars for security
          echo "TEST_ENV: dev"

      - name: Build the SDK for local test
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        run: yarn build

      - name: Test Core Functionality
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:core

      - name: Test Workflows
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:workflows

      - name: Test Executions
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:executions

      - name: Test Triggers
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:triggers

      - name: Test Nodes
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:nodes

      - name: Test Integrations
        if: github.event_name == 'workflow_dispatch' || steps.check_source_changes.outputs.source_changed == 'true'
        env:
          TEST_ENV: dev
        run: yarn test:integrations
