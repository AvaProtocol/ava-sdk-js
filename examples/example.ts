/**
 * Updated Ava Protocol SDK Example
 *
 * Key changes from previous versions:
 * 1. Authentication flow: getSignatureFormat() ‚Üí generateSignature() ‚Üí authWithSignature() ‚Üí setAuthKey()
 * 2. Most API methods no longer require passing { authKey } as second parameter
 * 3. Message format is generated by server via getSignatureFormat(), not composed locally
 * 4. Client maintains authentication state after setAuthKey() call
 * 5. Updated method names to match current API: getWorkflow, cancelWorkflow, deleteWorkflow, triggerWorkflow
 */

import { Client, TriggerFactory, NodeFactory, Edge } from "@avaprotocol/sdk-js";
import { NodeType, TriggerType, CustomCodeLang } from "@avaprotocol/types";

import _ from "lodash";
import { ethers } from "ethers";
import util from "node:util";
import id128library from "id128";
const { UlidMonotonic } = id128library;
import fs from "node:fs";
import path from "node:path";
import dotenv from "dotenv";

import { commandArgs, currentEnv, getConfig } from "./config";

// Load environment variables from root directory based on target environment
// This follows the same pattern as tests/utils/envalid.ts
const rootDir = path.join(__dirname, "..");

// 1. Load base .env file first (for common variables)
const baseEnvPath = path.join(rootDir, ".env");
if (fs.existsSync(baseEnvPath)) {
  console.log(`üìÅ Loading base environment from: .env`);
  dotenv.config({ path: baseEnvPath });
}

// 2. Then load environment-specific .env file if currentEnv is set
if (currentEnv && currentEnv !== "dev") {
  const envSpecificPath = path.join(rootDir, `.env.${currentEnv}`);
  if (fs.existsSync(envSpecificPath)) {
    console.log(`üìÅ Loading environment from: .env.${currentEnv}`);
    dotenv.config({ path: envSpecificPath, override: true });
  }
}

const config = getConfig();

const privateKey = process.env.TEST_PRIVATE_KEY; // Use consistent naming with test infrastructure
const avsApiKey = process.env.AVS_API_KEY; // API key for admin access to query any wallet

// Initialize SDK
console.log(
  "Current environment is: ",
  currentEnv,
  "endpoint: ",
  config.AP_AVS_RPC
);

const client = new Client({
  endpoint: config.AP_AVS_RPC,
});

const CHAT_ID = process.env.TELEGRAM_CHAT_ID || "-4609037622";

// Get wallet address from private key
async function getWalletAddress(privateKey: string): Promise<string> {
  const wallet = new ethers.Wallet(privateKey);
  return wallet.address;
}

// Generate a signed message from a private key
async function generateSignature(
  message: string,
  privateKey: string
): Promise<string> {
  const wallet = new ethers.Wallet(privateKey);
  const signature = await wallet.signMessage(message);
  return signature;
}

async function generateApiToken(targetAddress?: string) {
  // Check if API key is available for admin access
  if (avsApiKey) {
    if (!targetAddress) {
      throw new Error("‚ùå Target address is required when using API key authentication");
    }
    console.log("üîë Using API key authentication for admin access");
    const { message } = await client.getSignatureFormat(targetAddress);
    
    const result = await client.authWithAPIKey({
      message,
      apiKey: avsApiKey,
    });
    
    client.setAuthKey(result.authKey);
    return result;
  } else if (privateKey) {
    console.log("üîë Using signature-based authentication");
    const wallet = new ethers.Wallet(privateKey as string);
    const eoaAddress = wallet.address;

    // Get message from server for signing
    const { message } = await client.getSignatureFormat(eoaAddress);

    const signature = await generateSignature(message, privateKey as string);

    const result = await client.authWithSignature({
      message,
      signature,
    } as any);

    client.setAuthKey(result.authKey);
    return result;
  } else {
    throw new Error("‚ùå Either TEST_PRIVATE_KEY or AVS_API_KEY must be provided");
  }
}

async function getWorkflows(
  address: string,
  options: { cursor: string; limit: number }
) {
  // If no address provided, get wallets first and use their addresses
  let params: string[];

  if (!address || address.trim() === "") {
    console.log("No smart wallet address provided, fetching all wallets...");
    const wallets = await client.getWallets();

    if (_.isEmpty(wallets)) {
      console.log(
        "No wallets found. Please create a wallet first using 'getWallet <salt>'"
      );
      return;
    }

    params = _.map(wallets, (wallet: any) => wallet.address);
    console.log(`Found ${wallets.length} wallets:`, params);
  } else {
    params = _.split(address, ",");
  }

  const validOptions = {
    cursor: options.cursor || "",
    limit: options.limit || 20,
  };

  console.log(
    `Getting workflows for addresses`,
    params,
    `with cursor`,
    validOptions.cursor,
    `and limit`,
    validOptions.limit
  );

  try {
    const result = await client.getWorkflows(params, {
      after: validOptions.cursor,
      limit: validOptions.limit,
    });

    console.log(
      "getWorkflows response:\n",
      util.inspect(result, { depth: null, colors: true })
    );
  } catch (error: any) {
    if (
      error.message &&
      error.message.includes("invalid smart account address")
    ) {
      console.error("‚ùå Error: Invalid smart account address");
      console.error(
        "This means the address you provided is not owned by your authenticated account."
      );
      console.error("");
      console.error("To fix this:");
      console.error("1. First, check what wallets you own:");
      console.error("   yarn start getWallets");
      console.error("");
      console.error(
        "2. Then use one of those addresses, or create a new wallet:"
      );
      console.error("   yarn start getWallet <salt>");
      console.error("");
      console.error(
        "3. Or simply run without an address to use all your wallets:"
      );
      console.error("   yarn start getWorkflows");
    } else {
      console.error("‚ùå Error:", error.message || error);
    }
  }
}

async function getExecutions(
  workflowIdsString: string,
  options: {
    cursor?: string;
    limit?: number;
  } = { cursor: "", limit: 20 }
) {
  let workflowIds = [];

  if (_.isEmpty(workflowIdsString)) {
    const wallets = await client.getWallets();

    const workflows = await client.getWorkflows(
      _.map(wallets, (wallet: any) => wallet.address),
      {
        after: options.cursor,
        limit: options.limit,
      }
    );

    console.log(
      `Found ${wallets.length} wallets and ${workflows.items.length} workflows...`
    );

    // If there's no workflows found, return early
    if (_.isEmpty(workflows.items)) {
      console.log("No workflows found, returning early ...");
      return;
    }

    workflowIds = _.map(workflows.items, (workflow: any) => workflow.id);
  } else {
    workflowIds = _.split(workflowIdsString, ",");
  }

  const result = await client.getExecutions(workflowIds, {
    after: options.cursor,
    limit: options.limit,
  });

  console.log(
    "getExecutions response:\n",
    util.inspect(result, { depth: null, colors: true })
  );
}

async function triggerTask(owner, token, taskId, triggerReason) {
  const metadata = JSON.parse(triggerReason);

  const result = await client.triggerWorkflow({
    id: taskId,
    triggerData: {
      type: TriggerType.Event,
      blockNumber: metadata["block_number"],
      data: {
        logIndex: metadata["log_index"],
        txHash: metadata["tx_hash"],
      },
    },
    isBlocking: true,
  });

  console.log("request", { taskId: taskId, triggerReason });
  console.log("Response:\n", result);
}

async function getWallets(
  owner: string,
  token: string,
  shouldFetchBalances?: boolean
) {
  const walletsResp = await client.getWallets();

  if (shouldFetchBalances) {
    console.log("Fetching balances from RPC provider ...");
    // Update the provider creation
    const provider = new ethers.JsonRpcProvider(config.RPC_PROVIDER);

    // Get token balance
    const tokenAddress = config.TOKENS[token].address;
    const tokenAbi = [
      "function balanceOf(address account) view returns (uint256)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)",
    ];
    const tokenContract = new ethers.Contract(tokenAddress, tokenAbi, provider);

    let wallets = [];
    for (const wallet of walletsResp) {
      const balance = await provider.getBalance(wallet.address);
      const balanceInEth = _.floor(Number(ethers.formatEther(balance)), 2);

      const tokenBalance = await tokenContract.balanceOf(wallet.address);

      const tokenDecimals = await tokenContract.decimals();
      const tokenSymbol = await tokenContract.symbol();
      const tokenBalanceFormatted = _.floor(
        Number(ethers.formatUnits(tokenBalance, tokenDecimals)),
        2
      );
      wallets.push({
        ...wallet,
        balances: [
          `${balanceInEth} ETH`,
          `${tokenBalanceFormatted} ${tokenSymbol}`,
        ],
      });
    }

    return wallets;
  } else {
    return walletsResp;
  }
}

// Hide all wallets except the default salt:0 wallet
async function hideAllWallets() {
  console.log("Getting all wallets...");
  const wallets = await client.getWallets();

  const nonHiddenWallets = wallets.filter((wallet) => !wallet.isHidden);

  console.log(
    "Found nonHiddenWallets:\n",
    util.inspect(nonHiddenWallets, { depth: null, colors: true })
  );

  if (_.isEmpty(nonHiddenWallets)) {
    console.log("No wallets found to hide.");
    return;
  }

  console.log(
    `\nHiding ${nonHiddenWallets.length} wallets (excluding salt:0)...`
  );

  for (const wallet of nonHiddenWallets) {
    // Skip the default salt:0 wallet - never hide it
    if (wallet.salt === "0") {
      console.log(
        `Skipping default wallet with salt:0 (address: ${wallet.address})`
      );
      continue;
    }

    try {
      console.log(
        `Hiding wallet with salt:${wallet.salt} (address: ${wallet.address})...`
      );

      const result = await client.setWallet(
        {
          salt: wallet.salt,
          factoryAddress: wallet.factory,
        },
        { isHidden: true }
      );

      console.log(`‚úÖ Successfully hid wallet with salt:${wallet.salt}`);
    } catch (error) {
      console.error(
        `‚ùå Failed to hide wallet with salt:${wallet.salt}:`,
        error
      );
    }
  }

  console.log("\nüéâ Finished hiding wallets!");
}

function getTaskDataQuery(owner) {
  let ABI = ["function retrieve(address addr) public view returns (uint256)"];
  let iface = new ethers.Interface(ABI);
  return iface.encodeFunctionData("retrieve", [owner]);
}

// Schedule a simple job that get price of an asset and post it to a webhook
async function schedulePriceReport(
  schedules: string,
  smartWalletAddress: string
) {
  if (!smartWalletAddress) {
    console.log("invalid smart wallet address. check usage");
    return;
  }

  const triggerId: string = UlidMonotonic.generate().toCanonical();
  const nodeIdOraclePrice = UlidMonotonic.generate().toCanonical();
  const nodeIdNotification = UlidMonotonic.generate().toCanonical();

  let trigger = TriggerFactory.create({
    id: triggerId,
    type: TriggerType.Block,
    name: "demoTriggerName",
    data: {
      interval: 5,
    },
  });

  if (schedules === "schedule-cron") {
    trigger = TriggerFactory.create({
      id: triggerId,
      type: TriggerType.Cron,
      name: "demoCronTrigger",
      data: {
        // every 5 minutes, multiple crontab is also accepted
        schedules: ["*/2 * * * *"],
      },
    });
  }

  const workflow = client.createWorkflow({
    name: `price report every 5 blocks`,
    smartWalletAddress,
    nodes: NodeFactory.createNodes([
      {
        id: nodeIdOraclePrice,
        name: "checkPrice",
        type: NodeType.ContractRead,
        data: {
          contractAddress: config.ORACLES["ETH / USD"].address,
          contractAbi: [
            {
              inputs: [],
              name: "latestRoundData",
              outputs: [
                { internalType: "uint80", name: "roundId", type: "uint80" },
                { internalType: "int256", name: "answer", type: "int256" },
                { internalType: "uint256", name: "startedAt", type: "uint256" },
                { internalType: "uint256", name: "updatedAt", type: "uint256" },
                {
                  internalType: "uint80",
                  name: "answeredInRound",
                  type: "uint80",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
          ],
          methodCalls: [
            {
              callData: "0xfeaf968c",
              methodName: "latestRoundData",
            },
          ],
        },
      },
      {
        id: nodeIdNotification,
        name: "notification",
        type: NodeType.RestAPI,
        data: {
          //url: "https://api.telegram.org/bot{{apContext.configVars.ap_notify_bot_token}}/sendMessage",
          // Using this kind of website so you can interactly look at the request body, once it looks good and match telegram style, uncomment to use the above telegram url. It is important to use your own chat id
          url: "https://wet-butcher-89.webhook.cool",
          method: "POST",
          body: `{
            "chat_id": ${CHAT_ID},
            "text": "The result of latestRoundData at {{ new Date().getTime() }} of ETH/USD pair on ${currentEnv} network is {{ checkPrice.data.toString() }}."
          }`,
          headersMap: [["content-type", "application/json"]],
        },
      },
    ]),

    edges: [
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: triggerId,
        target: nodeIdOraclePrice,
      }),
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: nodeIdOraclePrice,
        target: nodeIdNotification,
      }),
    ],

    trigger,
    startAt: Date.now() + 30000, // Start in 30 seconds
    expiredAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days from now
    maxExecution: 1,
  });

  const workflowId = await client.submitWorkflow(workflow);

  console.log("create task", workflowId);
}

// setup a task to monitor in/out transfer for a wallet and send notification
async function scheduleTelegram(owner: string, token: string) {
  console.log("schedule a dummy telegram message");
  const wallets = await getWallets(owner, token);
  if (_.isEmpty(wallets)) {
    console.log(
      "please create at least one wallet. this example will then auto pick the first wallet to schedule the test"
    );
    return;
  }
  const smartWalletAddress = wallets[0].address;

  const nodeIdNotification = UlidMonotonic.generate().toCanonical();

  const triggerId = UlidMonotonic.generate().toCanonical();

  const workflow = client.createWorkflow({
    name: `dummy telegram msg ${new Date().toISOString()}`,
    smartWalletAddress,
    nodes: NodeFactory.createNodes([
      {
        id: nodeIdNotification,
        name: "notification",
        type: NodeType.RestAPI,
        data: {
          url: "https://api.telegram.org/bot{{apContext.configVars.ap_notify_bot_token}}/sendMessage?parse_mode=HTML",
          method: "POST",
          //body: `{
          //  "chat_id": -4609037622,
          //  "text": "Hello world scheduleTelegram Test. This task is triggered at block {{ triggerEvery10.data.block_number }}. we can also use use js in this block new Date() = {{ new Date() }}"
          //}`,

          body: `{
            "chat_id": 5197173428,
            "text": "Hello world scheduleTelegram Test on ${currentEnv} network. This task is triggered at block {{ triggerEvery10.data.block_number }}. we can also use use js in this block new Date() = {{ new Date() }}"
          }`,
          headersMap: [["content-type", "application/json"]],
        },
      },
    ]),

    edges: [
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: triggerId,
        target: nodeIdNotification,
      }),
    ],

    trigger: TriggerFactory.create({
      id: triggerId,
      type: TriggerType.Block,
      name: "triggerEvery10",
      data: {
        interval: 5,
      },
    }),
    startAt: Date.now() + 30000, // Start in 30 seconds
    expiredAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days from now
    maxExecution: 1,
  });

  const workflowId = await client.submitWorkflow(workflow);

  console.log("create task", workflowId);

  return workflowId;
}

// sweep is a highly dynamic task where the task isn't a fixed. It is essentially simulate an exchange deposit wallet. It works as follow
// 1. A task is setup to monitor a certain of token transfer in the wallet. Note: can also monitor all but don't want to waste gas for spam token
// 2. When the allowed token transfer it the smart wallet, we will transfer out the exact amount into a destination wallet
//
// The task demo how contractWrite node can be dynamic based on previous input
async function scheduleSweep(owner: string, token: string, target: string) {
  console.log(
    "schedule a sweep task that move incoming fund to another wallet"
  );
  const wallets = await getWallets(owner, token);
  if (_.isEmpty(wallets)) {
    console.log(
      "please create at least one wallet. this example will then auto pick the first wallet to schedule the test"
    );
    return;
  }
  const smartWalletAddress = wallets[0].address;

  const nodeIdCheckToken = UlidMonotonic.generate().toCanonical();
  const nodeIdLog = UlidMonotonic.generate().toCanonical();
  const nodeIdSweep = UlidMonotonic.generate().toCanonical();
  const branchIdCheckToken = UlidMonotonic.generate().toCanonical();

  const triggerId = UlidMonotonic.generate().toCanonical();

  const workflow = client.createWorkflow({
    name: `monitor transfer at ${new Date().toISOString()}`,
    smartWalletAddress,
    nodes: NodeFactory.createNodes([
      {
        id: nodeIdCheckToken,
        name: "checktoken",
        type: NodeType.Branch,
        data: {
          conditions: [
            {
              id: branchIdCheckToken,
              type: "if",
              // This can be an or to only sweep whitelist token such as usd and link
              expression: `["0x036cbd53842c5426634e7929541ec2318f3dcf7e", "0xe4ab69c077896252fafbd49efd26b5d171a32410"].indexOf(demoTriggerName.data.address.toLowerCase()) >= 0`,
            },
          ],
        },
      },
      {
        id: nodeIdLog,
        name: "log",
        type: NodeType.RestAPI,
        data: {
          //url: "https://api.telegram.org/bot{{apContext.configVars.ap_notify_bot_token}}/sendMessage?parse_mode=HTML",
          url: "https://wet-butcher-89.webhook.cool",
          method: "POST",
          // Update the chat id according to your own telegram bot
          body: `{{ demoTriggerName.data.toString() }}`,
          headersMap: [["content-type", "application/json"]],
        },
      },

      {
        id: nodeIdSweep,
        name: "sweep",
        type: NodeType.ContractWrite,
        data: {
          // At  run time this is dynamically evaluate
          contractAddress: "{{demoTriggerName.data.address}}",
          // Transfer whatever coming in to 0xe0f7d11fd714674722d325cd86062a5f1882e13a
          // Learn more how to compute these here https://ethereum.stackexchange.com/questions/114146/how-do-i-manually-encode-and-send-transaction-data and https://docs.ethers.org/v6/api/abi/#Interface-encodeFunctionData
          callData:
            "0xa9059cbb000000000000000000000000e0f7d11fd714674722d325cd86062a5f1882e13a{{ Number(demoTriggerName.data.value).toString(16).padStart(64, '0') }}",
          // Adding required contractAbi property
          contractAbi: [],
        },
      },
    ]),

    edges: [
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: triggerId,
        target: nodeIdCheckToken,
      }),
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: `${nodeIdCheckToken}.${branchIdCheckToken}`,
        target: nodeIdLog,
      }),
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: nodeIdLog,
        target: nodeIdSweep,
      }),
    ],

    trigger: TriggerFactory.create({
      id: triggerId,
      type: TriggerType.Event,
      name: "demoTriggerName",
      data: {
        queries: [
          {
            addresses: [
              "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
              "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
            ], // WETH and USDC
            topics: [
              {
                values: [
                  "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef", // Transfer event
                  "", // Any from address
                  target, // The wallet to monitor here
                ],
              },
            ],
            maxEventsPerBlock: 100,
          },
        ],
      },
    }),
    startAt: Date.now() + 30000, // Start in 30 seconds
    expiredAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days from now
    maxExecution: 1,
  });

  const workflowId = await client.submitWorkflow(workflow);

  console.log("create task", workflowId);

  return workflowId;
}

// Create a workflow with block trigger that performs ERC-20 contract write
async function scheduleContractWrite(
  owner: string,
  token: string,
  recipientAddress?: string,
  amount?: string
) {
  console.log("Creating contract write workflow with block trigger");

  const wallets = await getWallets(owner, token);
  if (_.isEmpty(wallets)) {
    console.log(
      "Please create at least one wallet. This example will auto pick the first wallet to schedule the test"
    );
    return;
  }
  const smartWalletAddress = wallets[0].address;

  // Default values based on the workflow data you provided
  const defaultRecipient =
    recipientAddress || "0xc60e71bd0f2e6d8832Fea1a2d56091C48493C788";
  const defaultAmount = amount || "10000"; // 0.01 USDC (6 decimals)
  const usdcAddress = config.TOKENS[token].address; // USDC address for current environment

  const triggerId = UlidMonotonic.generate().toCanonical();
  const contractWriteNodeId = UlidMonotonic.generate().toCanonical();

  // USDC ABI (minimal - just transfer function)
  const usdcAbi = [
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ];

  const workflow = client.createWorkflow({
    name: `Contract Write Test - ${new Date().toISOString()}`,
    smartWalletAddress,
    trigger: TriggerFactory.create({
      id: triggerId,
      name: "blockTrigger",
      type: TriggerType.Block,
      data: {
        interval: 10, // Every 10 blocks (about 2 minutes)
      },
    }),
    nodes: NodeFactory.createNodes([
      {
        id: contractWriteNodeId,
        name: "contractWrite1",
        type: NodeType.ContractWrite,
        data: {
          contractAddress: usdcAddress,
          contractAbi: usdcAbi,
          methodCalls: [
            {
              methodName: "transfer",
              methodParams: [defaultRecipient, defaultAmount],
            },
          ],
        },
      },
    ]),
    edges: [
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: triggerId,
        target: contractWriteNodeId,
      }),
    ],
    startAt: Date.now() + 30000, // Start in 30 seconds (30000 ms)
    expiredAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days from now (in ms)
    maxExecution: 5, // Limit to 5 executions for testing
  });

  const workflowId = await client.submitWorkflow(workflow);
  console.log("Contract write workflow created:", {
    id: workflowId,
    smartWalletAddress,
    contractAddress: usdcAddress,
    recipient: defaultRecipient,
    amount: defaultAmount,
    maxExecutions: 5,
  });

  return workflowId;
}

// setup a task to monitor in/out transfer for a wallet and send notification
async function scheduleMonitorTransfer(
  owner: string,
  token: string,
  target: string
) {
  console.log("schedule a monitor transfer task to the first smart wallet");
  const wallets = await getWallets(owner, token);
  if (_.isEmpty(wallets)) {
    console.log(
      "please create at least one wallet. this example will then auto pick the first wallet to schedule the test"
    );
    return;
  }
  const smartWalletAddress = wallets[0].address;

  const nodeIdNotification = UlidMonotonic.generate().toCanonical();
  const nodeIdCheckAmount = UlidMonotonic.generate().toCanonical();
  const branchIdCheckAmount = UlidMonotonic.generate().toCanonical();

  const triggerId = UlidMonotonic.generate().toCanonical();

  const workflow = client.createWorkflow({
    name: `monitor transfer at ${new Date().toISOString()}`,
    smartWalletAddress,
    nodes: NodeFactory.createNodes([
      {
        id: nodeIdCheckAmount,
        name: "checkAmount",
        type: NodeType.Branch,
        data: {
          conditions: [
            {
              id: branchIdCheckAmount,
              type: "if",
              //expression: `demoTriggerName.data.address == "0x036cbd53842c5426634e7929541ec2318f3dcf7e" && Number(demoTriggerName.data.value_formatted) > 1`,
              expression: `demoTriggerName.data.address == "0x036cbd53842c5426634e7929541ec2318f3dcf7e" && Number(demoTriggerName.data.value_formatted) > 0.005`,
            },
          ],
        },
      },
      {
        id: nodeIdNotification,
        name: "notification",
        type: NodeType.RestAPI,
        data: {
          //url: "https://api.telegram.org/bot{{apContext.configVars.ap_notify_bot_token}}/sendMessage?parse_mode=HTML",
          url: "https://wet-butcher-89.webhook.cool",
          method: "POST",
          // Update the chat id according to your own telegram bot
          body: `{
            "chat_id": -4609037622,
            "text": "Congrat, your walllet {{demoTriggerName.data.to_address}}(https://sepolia.etherscan.io/address/{{demoTriggerName.data.to_address}}) received {{demoTriggerName.data.value_formatted}} [{{demoTriggerName.data.token_symbol}}](https://sepolia.etherscan.io/token/{{demoTriggerName.data.address}}) from {{demoTriggerName.data.from_address}} at [{{demoTriggerName.data.transaction_hash}}](sepolia.etherscan.io/tx/{{demoTriggerName.data.transaction_hash}})"
          }`,
          headersMap: [["content-type", "application/json"]],
        },
      },
    ]),

    edges: [
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: triggerId,
        target: nodeIdCheckAmount,
      }),
      new Edge({
        id: UlidMonotonic.generate().toCanonical(),
        source: `${nodeIdCheckAmount}.${branchIdCheckAmount}`,
        target: nodeIdNotification,
      }),
    ],

    trigger: TriggerFactory.create({
      id: triggerId,
      type: TriggerType.Event,
      name: "demoTriggerName",
      data: {
        queries: [
          {
            addresses: [
              "0xaa8e23fb1079ea71e0a56f48a2aa51851d8433d0",
              "0x3e622317f8c93f7328350cf0b56d9ed4c620c5d6",
            ], // USDT and DAI
            topics: [
              {
                values: [
                  "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef", // Transfer event
                  "", // Any from address
                  target, // The wallet to monitor here
                ],
              },
            ],
            maxEventsPerBlock: 100,
          },
        ],
      },
    }),
    startAt: Date.now() + 30000, // Start in 30 seconds
    expiredAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days from now
    maxExecution: 1,
  });

  const workflowId = await client.submitWorkflow(workflow);

  console.log("create task", workflowId);

  return workflowId;
}

// Examine a workflow and write a sanitized log in the examples folder
async function examineWorkflow(workflowId: string) {
  if (!workflowId) {
    console.error("Usage: yarn start examineWorkflow <workflow-id>");
    return;
  }

  // Always use admin API key for examining workflows (required for cross-wallet access)
  const avsApiKey = process.env.AVS_API_KEY;
  if (!avsApiKey) {
    console.error("‚ùå AVS_API_KEY is required for examineWorkflow command");
    console.error("   This command needs admin privileges to access workflows from any wallet");
    return;
  }
  
  console.log(`üîë Using API key from .env.${currentEnv}`);

  const adminClient = new Client({
    endpoint: config.AP_AVS_RPC,
  });

  try {
    console.log("üîë Authenticating with admin API key...");
    const dummyAddress = "0x0000000000000000000000000000000000000000";
    const { message } = await adminClient.getSignatureFormat(dummyAddress);
    
    const result = await adminClient.authWithAPIKey({
      message,
      apiKey: avsApiKey,
    });
    
    adminClient.setAuthKey(result.authKey);
    console.log("‚úÖ Admin authentication successful");
  } catch (error) {
    console.error("‚ùå Admin API key authentication failed:", (error as Error).message);
    console.error("   Possible causes:");
    console.error("   1. API key is invalid or expired");
    console.error("   2. API key is for a different environment (dev/sepolia/base)");
    console.error("   3. API key doesn't have admin privileges");
    console.error(`   Current environment: ${currentEnv} (${config.AP_AVS_RPC})`);
    return;
  }

  try {
    
    // Now query the workflow using admin privileges
    const workflow = await adminClient.getWorkflow(workflowId);
    const execList: any = await adminClient.getExecutions([workflowId], { after: "", limit: 50 });
    const items: any[] = execList?.items || execList || [];
    const failed = items.find((e: any) => e && e.success === false) || items.find((e: any) => !!e?.error);
    let executionDetail: any = null;
    if (failed?.id) {
      executionDetail = await adminClient.getExecution(workflowId, failed.id);
    }
    
    const header = `examineWorkflow for ${workflowId}`;
    const wfStr = `\n=== Workflow ===\n` + util.inspect(workflow, { depth: null, colors: false });
    const firstFive = Array.isArray(items) ? items.slice(0, 5) : items;
    const listStr = `\n\n=== Executions (first 5) ===\n` + util.inspect(firstFive, { depth: null, colors: false });
    const detailStr = executionDetail
      ? `\n\n=== First Failed Execution Detail (${failed.id}) ===\n` + util.inspect(executionDetail, { depth: null, colors: false })
      : `\n\n=== First Failed Execution Detail ===\nNo failed execution found.`;
    let output = [header, wfStr, listStr, detailStr].join("\n");
    // Sanitize: redact bot token and chat_id
    output = output.replace(/https:\/\/api\.telegram\.org\/bot[0-9A-Za-z:_-]+/g, "https://api.telegram.org/bot<REDACTED>");
    output = output.replace(/\b(bot)([0-9A-Za-z:_-]{20,})/g, "$1<REDACTED>");
    output = output.replace(/(\"chat_id\"\s*:\s*\")(?:-?\d+)(\")/g, '$1<REDACTED>$2');
    const outFile = path.join(__dirname, `examineWorkflow.${workflowId}.sanitized.log`);
    fs.writeFileSync(outFile, output, "utf8");
    console.log(`\nWrote sanitized log: ${outFile}`);
    if (failed?.id) console.log(`First failed execution: ${failed.id}`);
  } catch (error) {
    console.error("‚ùå Failed to examine workflow:", error);
    console.error("This could be due to:");
    console.error("1. Workflow not found (check the workflow ID)");
    console.error("2. Network connectivity issues");
    console.error("3. Admin API key issues (already handled above)");
    throw error;
  }
}

// ‚ú® NEW: Example using input fields with triggers and nodes
export async function exampleWithInputFields() {
  const client = new Client({
    endpoint: "https://avs-aggregator-sepolia.avaprotocol.org",
  });

  // For now, let's comment out the input helper functions since they need to be properly exported
  // TODO: Uncomment when createInputData, extractInputData, hasInputData are properly exported

  /*
  // Create input data for the trigger
  const triggerInput = createInputData({
    timezone: "UTC",
    description: "Daily report generation",
    priority: "high"
  });

  // Create input data for the nodes
  const apiNodeInput = createInputData({
    timeout: 30000,
    retries: 3,
    headers: {
      "User-Agent": "AvaProtocol-SDK/1.0",
      "Accept": "application/json"
    }
  });

  const customCodeInput = createInputData({
    debugMode: true,
    maxProcessingTime: 60000,
    outputFormat: "json"
  });
  */

  // For now, manually create input data objects
  const triggerInput = {
    timezone: "UTC",
    description: "Daily report generation",
    priority: "high",
  };

  const apiNodeInput = {
    timeout: 30000,
    retries: 3,
    headers: {
      "User-Agent": "AvaProtocol-SDK/1.0",
      Accept: "application/json",
    },
  };

  const customCodeInput = {
    debugMode: true,
    maxProcessingTime: 60000,
    outputFormat: "json",
  };

  // Create a workflow with input fields
  const workflow = client.createWorkflow({
    name: "Daily Report with Input Data",
    trigger: {
      id: "daily-trigger",
      name: "dailyTrigger",
      type: TriggerType.Cron,
      data: {
        schedules: ["0 9 * * *"], // Every day at 9 AM
      },
      input: triggerInput as any, // ‚ú® NEW: Input data for the trigger (cast to any for now)
    },
    nodes: [
      {
        id: "fetch-data",
        name: "Fetch Market Data",
        type: NodeType.RestAPI,
        data: {
          url: "https://api.coingecko.com/api/v3/simple/price",
          method: "GET",
          body: "symbol=bitcoin&vs_currencies=usd",
          headersMap: [],
        },
        input: apiNodeInput as any, // ‚ú® NEW: Input data for the REST API node (cast to any for now)
      },
      {
        id: "process-data",
        name: "Process and Format Data",
        type: NodeType.CustomCode,
        data: {
          lang: CustomCodeLang.JavaScript,
          source: `
            // Access trigger input data
            const triggerConfig = dailyTrigger.input;
            console.log("Trigger timezone:", triggerConfig.timezone);
            console.log("Report priority:", triggerConfig.priority);
            
            // Access node input data
            const nodeConfig = fetch_data.input;
            console.log("API timeout setting:", nodeConfig.timeout);
            console.log("Retry count:", nodeConfig.retries);
            
            // Access actual output data (same as before)
            const marketData = fetch_data.data;
            
            // Access current node's input data
            const processingConfig = process_data.input;
            const debugMode = processingConfig.debugMode;
            
            if (debugMode) {
              console.log("Debug mode enabled");
              console.log("Market data:", JSON.stringify(marketData));
            }
            
            return {
              processedAt: new Date().toISOString(),
              price: marketData.bitcoin?.usd || 0,
              timezone: triggerConfig.timezone,
              format: processingConfig.outputFormat
            };
          `,
        },
        input: customCodeInput as any, // ‚ú® NEW: Input data for the custom code node (cast to any for now)
      },
    ],
    edges: [
      {
        id: "edge1",
        source: "daily-trigger",
        target: "fetch-data",
      },
      {
        id: "edge2",
        source: "fetch-data",
        target: "process-data",
      },
    ],
  });

  console.log("‚ú® Workflow with input fields created (example only)");
  console.log("- Trigger has input data:", !!(workflow.trigger as any).input);
  console.log(
    "- Nodes with input data:",
    workflow.nodes.filter((n) => !!(n as any).input).length
  );

  return workflow;
}

// Helper function to demonstrate input data concepts
export function demonstrateInputDataHelpers() {
  console.log("‚ú® Input Data Helper Functions Demo:");

  // Example input data structure
  const inputData = {
    timeout: 5000,
    retries: 3,
    headers: { Authorization: "Bearer token123" },
    nested: {
      config: { debug: true },
      values: [1, 2, 3],
    },
  };

  console.log("Input data example:", inputData);
  console.log(
    "This demonstrates the structure that will be supported once helper functions are exported"
  );

  return {
    inputData,
    hasInput: true,
    message: "Helper functions will be available in future SDK versions",
  };
}

const main = async (cmd: string) => {
  if (!privateKey && !avsApiKey) {
    console.log("‚ùå Either TEST_PRIVATE_KEY or AVS_API_KEY must be provided in environment variables");
    return;
  }
  
  let owner: string | null = null;
  let authKey: string | null = null;
  
  // Show wallet address if using private key (for informational purposes)
  if (privateKey) {
    const walletAddress = await getWalletAddress(privateKey);
    console.log("üîë Wallet:", walletAddress);
  }
  
  // For private key authentication (when no API key), authenticate immediately
  if (privateKey && !avsApiKey) {
    const result = await generateApiToken();
    owner = await getWalletAddress(privateKey);
    authKey = result.authKey;
  }
  // For API key authentication, we'll authenticate per-command as needed

  switch (commandArgs.command) {
    case "auth-key":
      if (authKey) {
        console.log("The authkey associate with the EOA is", authKey);
      } else {
        console.log("‚ùå Auth key not available. API key authentication requires target address for each command.");
      }
      break;
    case "getWallets": {
      const targetAddress = commandArgs.args[0]; // Optional address argument
      
      if (targetAddress) {
        // Address provided - use API key authentication for cross-user queries
        if (!avsApiKey) {
          console.error("‚ùå Error: API key is required to query wallets for specific addresses");
          console.error("   To query wallets for a specific address, set AVS_API_KEY in your environment");
          console.error("   To query your own wallets, use: yarn start getWallets (without address)");
          break;
        }
        console.log(`üîç Querying wallets for address: ${targetAddress} (using API key)`);
        await generateApiToken(targetAddress);
      } else {
        // No address provided - use private key authentication for own wallets
        if (!privateKey) {
          console.error("‚ùå Error: TEST_PRIVATE_KEY is required for signature-based authentication");
          console.error("   To query your own wallets, set TEST_PRIVATE_KEY in your environment");
          console.error("   To query specific addresses, use: yarn start getWallets <address> (requires AVS_API_KEY)");
          break;
        }
        console.log("üîç Getting wallets for authenticated user (using private key)");
        if (!authKey) {
          // Authenticate with private key if not already done
          console.log("üîë Using signature-based authentication");
          const wallet = new ethers.Wallet(privateKey);
          const eoaAddress = wallet.address;
          
          const { message } = await client.getSignatureFormat(eoaAddress);
          const signature = await generateSignature(message, privateKey);
          
          const result = await client.authWithSignature({
            message,
            signature,
          } as any);
          
          client.setAuthKey(result.authKey);
          authKey = result.authKey;
        }
      }
      
      const wallets = await client.getWallets();
      console.log(
        "getWallets response:\n",
        util.inspect(wallets, { depth: null, colors: true })
      );
      break;
    }
    case "hideAllWallets":
      await hideAllWallets();
      break;
    case "getWallet": {
      const salt = commandArgs.args[0];
      const factoryAddress = commandArgs.args[1]; // Optional factory address
      
      if (!salt) {
        console.error("‚ùå Error: Salt is required");
        console.error("   Usage: yarn start getWallet <salt> [factory-address]");
        console.error("   Example: yarn start getWallet 0");
        console.error("   Example: yarn start getWallet 1 0xFactoryAddress");
        break;
      }
      
      if (!privateKey) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for getWallet");
        break;
      }
      
      // Authenticate if not already done
      if (!authKey) {
        console.log("üîë Authenticating with signature-based auth...");
        const wallet = new ethers.Wallet(privateKey);
        const eoaAddress = wallet.address;
        
        const { message } = await client.getSignatureFormat(eoaAddress);
        const signature = await generateSignature(message, privateKey);
        
        const result = await client.authWithSignature({
          message,
          signature,
        } as any);
        
        client.setAuthKey(result.authKey);
        authKey = result.authKey;
        owner = eoaAddress;
      }
      
      console.log(`üìù Creating/getting smart wallet with salt ${salt}...`);
      const smartWalletAddress = await client.getWallet({
        salt,
        factoryAddress,
      });

      console.log(
        `‚úÖ Smart wallet with salt ${salt} for ${owner}:\n`,
        smartWalletAddress
      );
      break;
    }
    case "schedule-monitor":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for scheduling workflows");
        break;
      }
      scheduleMonitorTransfer(owner, authKey, commandArgs.args[0]);
      break;
    case "schedule-telegram":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for scheduling workflows");
        break;
      }
      scheduleTelegram(owner, authKey);
      break;
    case "schedule-sweep":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for scheduling workflows");
        break;
      }
      scheduleSweep(owner, authKey, commandArgs.args[0]);
      break;
    case "schedule-contract-write":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for scheduling workflows");
        break;
      }
      scheduleContractWrite(
        owner,
        authKey,
        commandArgs.args[0],
        commandArgs.args[1]
      );
      break;
    case "schedule":
    case "schedule-cron":
    case "schedule-fixed":
    case "schedule-manual": {
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for scheduling workflows");
        break;
      }
      const resultSchedule = await schedulePriceReport(
        commandArgs.args[0],
        commandArgs.args[1]
      );

      console.log(
        "schedule",
        util.inspect(resultSchedule, { depth: null, colors: true })
      );
      break;
    }

    case "getWorkflows": {
      const address = commandArgs.args[0] || ""; // Provide default empty string
      await getWorkflows(address, {
        cursor: commandArgs.args[1] || "",
        limit: _.toNumber(commandArgs.args[2]) || 20,
      });
      break;
    }

    case "getWorkflow": {
      const taskId = commandArgs.args[0];
      const result = await client.getWorkflow(taskId);

      console.log(
        "getWorkflow response:\n",
        util.inspect(result, { depth: null, colors: true })
      );
      break;
    }

    case "getExecutions":
      await getExecutions(commandArgs.args[0], {
        cursor: commandArgs.args[1],
        limit: _.toNumber(commandArgs.args[2]),
      });
      break;
    case "getExecution": {
      const workflowId = commandArgs.args[0];
      const executionId = commandArgs.args[1];
      
      if (!workflowId || !executionId) {
        console.error("‚ùå Usage: yarn start getExecution <workflow-id> <execution-id>");
        break;
      }

      // For getExecution, prefer API key authentication if available (allows cross-wallet access)
      let executionClient = client;
      
      if (avsApiKey) {
        console.log("üîë Using API key authentication for execution access...");
        
        // Create a separate client for API key authentication
        executionClient = new Client({
          endpoint: config.AP_AVS_RPC,
        });
        
        try {
          // Use a dummy address for API key authentication (admin access)
          const dummyAddress = "0x0000000000000000000000000000000000000000";
          const { message } = await executionClient.getSignatureFormat(dummyAddress);
          
          const result = await executionClient.authWithAPIKey({
            message,
            apiKey: avsApiKey,
          });
          
          executionClient.setAuthKey(result.authKey);
          console.log("‚úÖ API key authentication successful");
        } catch (error) {
          console.error("‚ùå API key authentication failed:", (error as Error).message);
          console.error("   Possible causes:");
          console.error("   1. API key is invalid or expired");
          console.error("   2. API key is for a different environment (dev/sepolia/base)");
          console.error("   3. API key doesn't have admin privileges");
          console.error(`   Current environment: ${currentEnv} (${config.AP_AVS_RPC})`);
          break;
        }
      } else if (privateKey) {
        console.log("üîë Using signature-based authentication...");
        
        // Ensure we're authenticated with private key
        if (!authKey) {
          console.log("üîë Authenticating with signature-based auth...");
          const wallet = new ethers.Wallet(privateKey);
          const eoaAddress = wallet.address;
          
          const { message } = await executionClient.getSignatureFormat(eoaAddress);
          const signature = await generateSignature(message, privateKey);
          
          const result = await executionClient.authWithSignature({
            message,
            signature,
          } as any);
          
          executionClient.setAuthKey(result.authKey);
        }
      } else {
        console.error("‚ùå Either TEST_PRIVATE_KEY or AVS_API_KEY must be provided");
        break;
      }

      try {
        const resultExecution = await executionClient.getExecution(workflowId, executionId);

        console.log(
          "getExecution response:\n",
          util.inspect(resultExecution, { depth: null, colors: true })
        );
      } catch (error: any) {
        console.error("‚ùå Failed to get execution:", error.message || error);
        console.error("   Possible causes:");
        console.error("   1. Workflow or execution ID not found");
        console.error("   2. You don't have permission to access this execution");
        console.error("   3. Network connectivity issues");
        if (error.code === 16) { // UNAUTHENTICATED
          console.error("   4. Authentication failed - check your API key or private key");
        }
      }
      break;
    }
    case "examineWorkflow": {
      const workflowId = commandArgs.args[0];
      await examineWorkflow(workflowId);
      break;
    }
    case "cancelWorkflow": {
      console.log("Cancelling workflow", commandArgs.args[0]);
      const resultCancel = await client.cancelWorkflow(commandArgs.args[0]);
      console.log("Response:\n", resultCancel);
      break;
    }
    case "deleteWorkflow": {
      const resultDelete = await client.deleteWorkflow(commandArgs.args[0]);
      console.log("Response:\n", resultDelete);
      break;
    }

    case "gen-task-data":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for generating task data");
        break;
      }
      console.log("pack contract call", getTaskDataQuery(owner));
      break;

    case "trigger":
      if (!owner) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for triggering workflows");
        break;
      }
      await triggerTask(
        owner,
        authKey,
        commandArgs.args[0],
        commandArgs.args[1]
      );
      break;

    case "create-secret": {
      const isSuccess = await client.createSecret(
        commandArgs.args[0],
        commandArgs.args[1]
      );

      console.log(
        "secret",
        util.inspect(isSuccess, { depth: null, colors: true })
      );
      break;
    }
    case "list-secrets": {
      const secrets = await client.getSecrets();
      console.log(
        "secrets",
        util.inspect(secrets, { depth: null, colors: true })
      );
      break;
    }
    case "example-with-input-fields": {
      await exampleWithInputFields();
      break;
    }
    case "demonstrate-input-data-helpers":
      demonstrateInputDataHelpers();
      break;

    case "withdraw": {
      if (!privateKey) {
        console.log("‚ùå TEST_PRIVATE_KEY is required for withdrawal testing");
        break;
      }
      
      // Authenticate first
      if (!authKey) {
        console.log("üîë Authenticating with signature-based auth...");
        const wallet = new ethers.Wallet(privateKey);
        const eoaAddress = wallet.address;
        
        const { message } = await client.getSignatureFormat(eoaAddress);
        const signature = await generateSignature(message, privateKey);
        
        const result = await client.authWithSignature({
          message,
          signature,
        } as any);
        
        client.setAuthKey(result.authKey);
        authKey = result.authKey;
        owner = eoaAddress;
      }
      
      // Smart parameter parsing: detect if first arg is amount (number) or address (0x...)
      let recipientAddress = owner; // Default to EOA owner
      let amountInEth = "0.01"; // Default 0.01 ETH
      let token = "ETH"; // Default token
      
      if (commandArgs.args.length > 0) {
        const firstArg = commandArgs.args[0];
        if (firstArg.startsWith("0x")) {
          // First arg is an address
          recipientAddress = firstArg;
          amountInEth = commandArgs.args[1] || "0.01";
          token = commandArgs.args[2] || "ETH";
        } else {
          // First arg is amount, use default recipient (EOA owner)
          amountInEth = firstArg;
          token = commandArgs.args[1] || "ETH";
        }
      }
      
      // Convert ETH to wei for API call
      const amountInWei = ethers.parseEther(amountInEth).toString();
      
      try {
        console.log("üîç Testing withdrawal flow...");
        console.log("  Authenticated user:", owner);
        console.log("  Recipient:", recipientAddress);
        console.log("  Amount:", `${amountInEth} ETH (${amountInWei} wei)`);
        console.log("  Token:", token);
        
        // First, get the user's wallet (this should create it if it doesn't exist)
        console.log("üìù Step 1: Getting user's wallet with salt 0...");
        const wallet = await client.getWallet({ salt: "0" });
        console.log("‚úÖ Wallet obtained:", wallet.address);
        
        // Then attempt withdrawal
        console.log("üí∞ Step 2: Attempting withdrawal...");
        const withdrawRequest = {
          recipientAddress: recipientAddress,
          amount: amountInWei, // Use wei amount for API
          token: token,
          smartWalletAddress: wallet.address,
        };
        
        console.log("üì° Withdrawal request:", withdrawRequest);
        
        const response = await client.withdrawFunds(withdrawRequest, { timeout: { timeout: 180000 } });
        
        console.log("‚úÖ Withdrawal response:", {
          success: response.success,
          status: response.status,
          message: response.message,
          userOpHash: response.userOpHash,
          transactionHash: response.transactionHash,
          smartWalletAddress: response.smartWalletAddress,
        });
        
      } catch (error: any) {
        console.error("‚ùå Withdrawal failed:", error.message);
        console.error("   Full error:", error);
      }
      break;
    }

    default:
      console.log(`Usage:

      getWallet <salt> <factory-address(optional)>:      to create/get a smart wallet with a salt, and optionally a factory contract
      getWallets:                                         to list smart wallet addresses that have been created
      hideAllWallets:                                     to hide all wallets except the default salt:0 wallet
      withdraw [recipient-address] [amount-eth] [token]:   to test withdrawal functionality (defaults to EOA owner, 0.01 ETH)
      getWorkflows <smart-wallet>,... <cursor> <limit>:  to list all workflows of given smart wallet addresses, with cursor and limit
      getWorkflow <workflow-id>:                          to get workflow detail. a permission error is thrown if the eoa isn't the smart wallet owner
      getExecutions <workflow-id> <cursor> <limit>:       to get workflow execution history. a permission error is thrown if the eoa isn't the smart wallet owner
      getExecution <workflow-id> <execution-id>:          to get a single workflow execution. a permission error is thrown if the eoa isn't the smart wallet owner
      examineWorkflow <workflow-id>:                       fetch workflow, list executions, fetch details of first failed execution, write sanitized .log in examples
      schedule <smart-wallet-address>:                    to schedule a task that run on every block, with chainlink eth-usd its condition will be matched quickly
      schedule-cron <smart-wallet-address>:               same as above, but run on cron
      schedule-monitor <wallet-address>:                  to monitor erc20 in/out for an address
      schedule-telegram:                                  to schedule a dummy task that send a fix message to telegram every 10 blocks
      schedule-sweep <smart-wallet-address>:              when fund arrive to smart wallet, route them to other address, simulate exchange deposit
      trigger <workflow-id> <trigger-metadata>:           manually trigger a workflow. Example:
                                                            trigger abcdef '{"block_number":1234}' for block trigger
                                                            trigger abcdef '{"block_number":1234, "log_index":312,"tx_hash":"0x123"}' for event trigger
                                                            trigger abcdef '{"epoch":1234, "log_index":312,"tx_hash":"0x123"}' for time based trigger (fixed or cron)
      cancelWorkflow <workflow-id>:                       to cancel a workflow
      deleteWorkflow <workflow-id>:                       to completely remove a workflow
      create-secret <name> <value>:                       create a user secret that is available to all workflows
      list-secrets:                                       list all user secrets
      gen-task-data:                                      generate a task data for a contract call
      auth-key:                                           get auth key for your EOA when you want to construct grpc call manually
      example-with-input-fields:                          example using input fields with triggers and nodes
      demonstrate-input-data-helpers:                      demonstrate input data helpers
      `);
  }
};

(async () => {
  main(process.argv[2]);
})();
