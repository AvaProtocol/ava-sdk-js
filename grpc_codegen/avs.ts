// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.19.1
// source: avs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Timestamp } from "./google/protobuf/timestamp";
import { BoolValue } from "./google/protobuf/wrappers";

export const protobufPackage = "aggregator";

export enum TriggerType {
  TimeTrigger = 0,
  ContractQueryTrigger = 1,
  ExpressionTrigger = 2,
  UNRECOGNIZED = -1,
}

export function triggerTypeFromJSON(object: any): TriggerType {
  switch (object) {
    case 0:
    case "TimeTrigger":
      return TriggerType.TimeTrigger;
    case 1:
    case "ContractQueryTrigger":
      return TriggerType.ContractQueryTrigger;
    case 2:
    case "ExpressionTrigger":
      return TriggerType.ExpressionTrigger;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TriggerType.UNRECOGNIZED;
  }
}

export function triggerTypeToJSON(object: TriggerType): string {
  switch (object) {
    case TriggerType.TimeTrigger:
      return "TimeTrigger";
    case TriggerType.ContractQueryTrigger:
      return "ContractQueryTrigger";
    case TriggerType.ExpressionTrigger:
      return "ExpressionTrigger";
    case TriggerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskType represents what kind of work the task will perform */
export enum TaskType {
  /** ETHTransferTask - Handle default/missing data */
  ETHTransferTask = 0,
  /**
   * ContractExecutionTask - Generic contract execution which can be used for:
   * ERC20 Transfer, NFT Transfer, auto reclaim, auto restaking etc
   * When executing a contract we need at least 2 things:
   * - target contract address
   * - the message to send to that contract
   */
  ContractExecutionTask = 1,
  GraphQLDataQueryTask = 2,
  /** HTTPAPICallTask - Make call to a HTTP endpoint */
  HTTPAPICallTask = 3,
  /** CustomCodeTask - CustomCode allow to run arbitraty JavaScript. */
  CustomCodeTask = 4,
  BranchActionTask = 5,
  UNRECOGNIZED = -1,
}

export function taskTypeFromJSON(object: any): TaskType {
  switch (object) {
    case 0:
    case "ETHTransferTask":
      return TaskType.ETHTransferTask;
    case 1:
    case "ContractExecutionTask":
      return TaskType.ContractExecutionTask;
    case 2:
    case "GraphQLDataQueryTask":
      return TaskType.GraphQLDataQueryTask;
    case 3:
    case "HTTPAPICallTask":
      return TaskType.HTTPAPICallTask;
    case 4:
    case "CustomCodeTask":
      return TaskType.CustomCodeTask;
    case 5:
    case "BranchActionTask":
      return TaskType.BranchActionTask;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskType.UNRECOGNIZED;
  }
}

export function taskTypeToJSON(object: TaskType): string {
  switch (object) {
    case TaskType.ETHTransferTask:
      return "ETHTransferTask";
    case TaskType.ContractExecutionTask:
      return "ContractExecutionTask";
    case TaskType.GraphQLDataQueryTask:
      return "GraphQLDataQueryTask";
    case TaskType.HTTPAPICallTask:
      return "HTTPAPICallTask";
    case TaskType.CustomCodeTask:
      return "CustomCodeTask";
    case TaskType.BranchActionTask:
      return "BranchActionTask";
  case TaskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskStatus represents status of the task. The transition is as follow */
export enum TaskStatus {
  Active = 0,
  Completed = 1,
  Failed = 2,
  Canceled = 3,
  Executing = 4,
  UNRECOGNIZED = -1,
}

export function taskStatusFromJSON(object: any): TaskStatus {
  switch (object) {
    case 0:
    case "Active":
      return TaskStatus.Active;
    case 1:
    case "Completed":
      return TaskStatus.Completed;
    case 2:
    case "Failed":
      return TaskStatus.Failed;
    case 3:
    case "Canceled":
      return TaskStatus.Canceled;
    case 4:
    case "Executing":
      return TaskStatus.Executing;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskStatus.UNRECOGNIZED;
  }
}

export function taskStatusToJSON(object: TaskStatus): string {
  switch (object) {
    case TaskStatus.Active:
      return "Active";
    case TaskStatus.Completed:
      return "Completed";
    case TaskStatus.Failed:
      return "Failed";
    case TaskStatus.Canceled:
      return "Canceled";
    case TaskStatus.Executing:
      return "Executing";
    case TaskStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CustomCodeType {
  JavaScript = 0,
  UNRECOGNIZED = -1,
}

export function customCodeTypeFromJSON(object: any): CustomCodeType {
  switch (object) {
    case 0:
    case "JavaScript":
      return CustomCodeType.JavaScript;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomCodeType.UNRECOGNIZED;
  }
}

export function customCodeTypeToJSON(object: CustomCodeType): string {
  switch (object) {
    case CustomCodeType.JavaScript:
      return "JavaScript";
    case CustomCodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UUID {
  bytes: string;
}

export interface Checkin {
  id: string;
  address: string;
  signature: string;
  status: Checkin_Status | undefined;
  version: string;
  metricsPort: number;
  remoteIP: string;
}

export interface Checkin_Status {
  uptime: number;
  queueDepth: number;
  lastHeartbeat: Date | undefined;
}

export interface CheckinResp {
  updatedAt: Date | undefined;
}

export interface SyncTasksReq {
  id: string;
  address: string;
  signature: string;
  monotonicClock: number;
}

export interface TaskTrigger {
  triggerType: TriggerType;
  schedule: TimeCondition | undefined;
  contractQuery: ContractQueryCondition | undefined;
  expression: ExpressionCondition | undefined;
}

/** Simple timebase or cron syntax. */
export interface TimeCondition {
  fixed: number[];
  cron: string;
}

/**
 * A contract method that return true/false
 * Ideally to use when we already have an existing contract that perform the
 * check.
 * This method will be evaluate every block
 */
export interface ContractQueryCondition {
  contractAddress: string;
  callmsg: string;
}

/**
 * An arbitrary expression to express the condition.
 * People can define condition example
 *   chainlinkPrice("address-of-eth-usd-pair") > 2644500 && queryContract("contractaddress", "callmsg")[2] < = 5
 * By allow arbitrary expression, people can mix and match to create conplex
 * condition that match their workload
 *
 * The function to be used need to be pre-defined on our task egnine runtime.
 * When a new block is build, our engine will execute these check
 *
 * The expression language is re-present by https://expr-lang.org/
 */
export interface ExpressionCondition {
  expression: string;
}

export interface SyncTasksResp {
  id: string;
  checkType: string;
  trigger: TaskTrigger | undefined;
}

export interface ETHTransfer {
  destination: string;
  amount: string;
}

export interface ContractExecution {
  contractAddress: string;
  callData: string;
  method: string;
  encodedParams: string;
}

export interface GraphQLDataQuery {
  /** TODO: support graphql variable */
  url: string;
  query: string;
}

export interface HTTPAPICall {
  url: string;
  headers: { [key: string]: string };
  body: string;
}

export interface HTTPAPICall_HeadersEntry {
  key: string;
  value: string;
}

export interface CustomCode {
  type: CustomCodeType;
  body: string;
}

export interface ConditionJump {
  expression: string;
  next: string;
}

export interface BranchAction {
  If: ConditionJump | undefined;
  ElseIfs: ConditionJump[];
  Else: ConditionJump | undefined;
}

export interface TaskAction {
  taskType: TaskType;
  id: string;
  name: string;
  /**
   * Next can be empty. In some kind of block, such as branching, the next is
   * based on branching condition
   */
  next: string[];
  /** Transfer eth */
  ethTransfer:
    | ETHTransfer
    | undefined;
  /**
   * Run one ore more contracts. The call call also be batched with tool like
   * multicall to wrap many calls
   */
  contractExecution:
    | ContractExecution
    | undefined;
  /** Make call to a graphql endpoint */
  graphqlDataQuery:
    | GraphQLDataQuery
    | undefined;
  /** Make call to a HTTP endpoint */
  httpDataQuery:
    | HTTPAPICall
    | undefined;
  /** CustomCode allow to run arbitraty JavaScript. */
  customCode: CustomCode | undefined;
  branch: BranchAction | undefined;
}

export interface Execution {
  epoch: number;
  userOpHash: string;
  error: string;
}

export interface Task {
  id: UUID | undefined;
  owner: string;
  smartAccountAddress: string;
  trigger: TaskTrigger | undefined;
  nodes: TaskAction[];
  /** task won't be check before this */
  startAt: number;
  /** task won't be run/check after this */
  expiredAt: number;
  /** arbitrary data about this task */
  memo: string;
  completedAt: number;
  status: TaskStatus;
  /** repeatable means a task can continue to run even after the first execution */
  repeatable: boolean;
  executions: Execution[];
}

export interface CreateTaskReq {
  trigger: TaskTrigger | undefined;
  actions: TaskAction[];
  startAt: number;
  expiredAt: number;
  memo: string;
  /** A repeatable task will continue to be run */
  repeatable: boolean;
}

export interface CreateTaskResp {
  id: string;
}

export interface NonceRequest {
  owner: string;
}

export interface NonceResp {
  nonce: string;
}

export interface AddressRequest {
  owner: string;
}

export interface AddressResp {
  smartAccountAddress: string;
  nonce: string;
}

export interface ListTasksReq {
}

export interface ListTasksResp {
  tasks: ListTasksResp_TaskItemResp[];
}

export interface ListTasksResp_TaskItemResp {
  id: string;
  status: TaskStatus;
}

export interface GetKeyReq {
  owner: string;
  expiredAt: number;
  signature: string;
}

export interface KeyResp {
  key: string;
}

export interface UpdateChecksReq {
  address: string;
  signature: string;
  id: string[];
}

export interface UpdateChecksResp {
  updatedAt: Date | undefined;
}

function createBaseUUID(): UUID {
  return { bytes: "" };
}

export const UUID: MessageFns<UUID> = {
  encode(message: UUID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytes !== "") {
      writer.uint32(10).string(message.bytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UUID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUUID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UUID {
    return { bytes: isSet(object.bytes) ? globalThis.String(object.bytes) : "" };
  },

  toJSON(message: UUID): unknown {
    const obj: any = {};
    if (message.bytes !== "") {
      obj.bytes = message.bytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UUID>, I>>(base?: I): UUID {
    return UUID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UUID>, I>>(object: I): UUID {
    const message = createBaseUUID();
    message.bytes = object.bytes ?? "";
    return message;
  },
};

function createBaseCheckin(): Checkin {
  return { id: "", address: "", signature: "", status: undefined, version: "", metricsPort: 0, remoteIP: "" };
}

export const Checkin: MessageFns<Checkin> = {
  encode(message: Checkin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.status !== undefined) {
      Checkin_Status.encode(message.status, writer.uint32(34).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.metricsPort !== 0) {
      writer.uint32(48).int32(message.metricsPort);
    }
    if (message.remoteIP !== "") {
      writer.uint32(58).string(message.remoteIP);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Checkin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = Checkin_Status.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.metricsPort = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.remoteIP = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Checkin {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      status: isSet(object.status) ? Checkin_Status.fromJSON(object.status) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      metricsPort: isSet(object.metricsPort) ? globalThis.Number(object.metricsPort) : 0,
      remoteIP: isSet(object.remoteIP) ? globalThis.String(object.remoteIP) : "",
    };
  },

  toJSON(message: Checkin): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.status !== undefined) {
      obj.status = Checkin_Status.toJSON(message.status);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.metricsPort !== 0) {
      obj.metricsPort = Math.round(message.metricsPort);
    }
    if (message.remoteIP !== "") {
      obj.remoteIP = message.remoteIP;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Checkin>, I>>(base?: I): Checkin {
    return Checkin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Checkin>, I>>(object: I): Checkin {
    const message = createBaseCheckin();
    message.id = object.id ?? "";
    message.address = object.address ?? "";
    message.signature = object.signature ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Checkin_Status.fromPartial(object.status)
      : undefined;
    message.version = object.version ?? "";
    message.metricsPort = object.metricsPort ?? 0;
    message.remoteIP = object.remoteIP ?? "";
    return message;
  },
};

function createBaseCheckin_Status(): Checkin_Status {
  return { uptime: 0, queueDepth: 0, lastHeartbeat: undefined };
}

export const Checkin_Status: MessageFns<Checkin_Status> = {
  encode(message: Checkin_Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uptime !== 0) {
      writer.uint32(8).int64(message.uptime);
    }
    if (message.queueDepth !== 0) {
      writer.uint32(16).int64(message.queueDepth);
    }
    if (message.lastHeartbeat !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeat), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Checkin_Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckin_Status();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uptime = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.queueDepth = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastHeartbeat = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Checkin_Status {
    return {
      uptime: isSet(object.uptime) ? globalThis.Number(object.uptime) : 0,
      queueDepth: isSet(object.queueDepth) ? globalThis.Number(object.queueDepth) : 0,
      lastHeartbeat: isSet(object.lastHeartbeat) ? fromJsonTimestamp(object.lastHeartbeat) : undefined,
    };
  },

  toJSON(message: Checkin_Status): unknown {
    const obj: any = {};
    if (message.uptime !== 0) {
      obj.uptime = Math.round(message.uptime);
    }
    if (message.queueDepth !== 0) {
      obj.queueDepth = Math.round(message.queueDepth);
    }
    if (message.lastHeartbeat !== undefined) {
      obj.lastHeartbeat = message.lastHeartbeat.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Checkin_Status>, I>>(base?: I): Checkin_Status {
    return Checkin_Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Checkin_Status>, I>>(object: I): Checkin_Status {
    const message = createBaseCheckin_Status();
    message.uptime = object.uptime ?? 0;
    message.queueDepth = object.queueDepth ?? 0;
    message.lastHeartbeat = object.lastHeartbeat ?? undefined;
    return message;
  },
};

function createBaseCheckinResp(): CheckinResp {
  return { updatedAt: undefined };
}

export const CheckinResp: MessageFns<CheckinResp> = {
  encode(message: CheckinResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckinResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckinResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckinResp {
    return { updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined };
  },

  toJSON(message: CheckinResp): unknown {
    const obj: any = {};
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckinResp>, I>>(base?: I): CheckinResp {
    return CheckinResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckinResp>, I>>(object: I): CheckinResp {
    const message = createBaseCheckinResp();
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseSyncTasksReq(): SyncTasksReq {
  return { id: "", address: "", signature: "", monotonicClock: 0 };
}

export const SyncTasksReq: MessageFns<SyncTasksReq> = {
  encode(message: SyncTasksReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.monotonicClock !== 0) {
      writer.uint32(32).int64(message.monotonicClock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncTasksReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTasksReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.monotonicClock = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncTasksReq {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      monotonicClock: isSet(object.monotonicClock) ? globalThis.Number(object.monotonicClock) : 0,
    };
  },

  toJSON(message: SyncTasksReq): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.monotonicClock !== 0) {
      obj.monotonicClock = Math.round(message.monotonicClock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncTasksReq>, I>>(base?: I): SyncTasksReq {
    return SyncTasksReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncTasksReq>, I>>(object: I): SyncTasksReq {
    const message = createBaseSyncTasksReq();
    message.id = object.id ?? "";
    message.address = object.address ?? "";
    message.signature = object.signature ?? "";
    message.monotonicClock = object.monotonicClock ?? 0;
    return message;
  },
};

function createBaseTaskTrigger(): TaskTrigger {
  return { triggerType: 0, schedule: undefined, contractQuery: undefined, expression: undefined };
}

export const TaskTrigger: MessageFns<TaskTrigger> = {
  encode(message: TaskTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.triggerType !== 0) {
      writer.uint32(8).int32(message.triggerType);
    }
    if (message.schedule !== undefined) {
      TimeCondition.encode(message.schedule, writer.uint32(18).fork()).join();
    }
    if (message.contractQuery !== undefined) {
      ContractQueryCondition.encode(message.contractQuery, writer.uint32(26).fork()).join();
    }
    if (message.expression !== undefined) {
      ExpressionCondition.encode(message.expression, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.triggerType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schedule = TimeCondition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractQuery = ContractQueryCondition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expression = ExpressionCondition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskTrigger {
    return {
      triggerType: isSet(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      schedule: isSet(object.schedule) ? TimeCondition.fromJSON(object.schedule) : undefined,
      contractQuery: isSet(object.contractQuery) ? ContractQueryCondition.fromJSON(object.contractQuery) : undefined,
      expression: isSet(object.expression) ? ExpressionCondition.fromJSON(object.expression) : undefined,
    };
  },

  toJSON(message: TaskTrigger): unknown {
    const obj: any = {};
    if (message.triggerType !== 0) {
      obj.triggerType = triggerTypeToJSON(message.triggerType);
    }
    if (message.schedule !== undefined) {
      obj.schedule = TimeCondition.toJSON(message.schedule);
    }
    if (message.contractQuery !== undefined) {
      obj.contractQuery = ContractQueryCondition.toJSON(message.contractQuery);
    }
    if (message.expression !== undefined) {
      obj.expression = ExpressionCondition.toJSON(message.expression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskTrigger>, I>>(base?: I): TaskTrigger {
    return TaskTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskTrigger>, I>>(object: I): TaskTrigger {
    const message = createBaseTaskTrigger();
    message.triggerType = object.triggerType ?? 0;
    message.schedule = (object.schedule !== undefined && object.schedule !== null)
      ? TimeCondition.fromPartial(object.schedule)
      : undefined;
    message.contractQuery = (object.contractQuery !== undefined && object.contractQuery !== null)
      ? ContractQueryCondition.fromPartial(object.contractQuery)
      : undefined;
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? ExpressionCondition.fromPartial(object.expression)
      : undefined;
    return message;
  },
};

function createBaseTimeCondition(): TimeCondition {
  return { fixed: [], cron: "" };
}

export const TimeCondition: MessageFns<TimeCondition> = {
  encode(message: TimeCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.fixed) {
      writer.int64(v);
    }
    writer.join();
    if (message.cron !== "") {
      writer.uint32(18).string(message.cron);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.fixed.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fixed.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cron = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeCondition {
    return {
      fixed: globalThis.Array.isArray(object?.fixed) ? object.fixed.map((e: any) => globalThis.Number(e)) : [],
      cron: isSet(object.cron) ? globalThis.String(object.cron) : "",
    };
  },

  toJSON(message: TimeCondition): unknown {
    const obj: any = {};
    if (message.fixed?.length) {
      obj.fixed = message.fixed.map((e) => Math.round(e));
    }
    if (message.cron !== "") {
      obj.cron = message.cron;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeCondition>, I>>(base?: I): TimeCondition {
    return TimeCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeCondition>, I>>(object: I): TimeCondition {
    const message = createBaseTimeCondition();
    message.fixed = object.fixed?.map((e) => e) || [];
    message.cron = object.cron ?? "";
    return message;
  },
};

function createBaseContractQueryCondition(): ContractQueryCondition {
  return { contractAddress: "", callmsg: "" };
}

export const ContractQueryCondition: MessageFns<ContractQueryCondition> = {
  encode(message: ContractQueryCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.callmsg !== "") {
      writer.uint32(18).string(message.callmsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractQueryCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractQueryCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callmsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractQueryCondition {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      callmsg: isSet(object.callmsg) ? globalThis.String(object.callmsg) : "",
    };
  },

  toJSON(message: ContractQueryCondition): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.callmsg !== "") {
      obj.callmsg = message.callmsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContractQueryCondition>, I>>(base?: I): ContractQueryCondition {
    return ContractQueryCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContractQueryCondition>, I>>(object: I): ContractQueryCondition {
    const message = createBaseContractQueryCondition();
    message.contractAddress = object.contractAddress ?? "";
    message.callmsg = object.callmsg ?? "";
    return message;
  },
};

function createBaseExpressionCondition(): ExpressionCondition {
  return { expression: "" };
}

export const ExpressionCondition: MessageFns<ExpressionCondition> = {
  encode(message: ExpressionCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpressionCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpressionCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpressionCondition {
    return { expression: isSet(object.expression) ? globalThis.String(object.expression) : "" };
  },

  toJSON(message: ExpressionCondition): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpressionCondition>, I>>(base?: I): ExpressionCondition {
    return ExpressionCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpressionCondition>, I>>(object: I): ExpressionCondition {
    const message = createBaseExpressionCondition();
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseSyncTasksResp(): SyncTasksResp {
  return { id: "", checkType: "", trigger: undefined };
}

export const SyncTasksResp: MessageFns<SyncTasksResp> = {
  encode(message: SyncTasksResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.checkType !== "") {
      writer.uint32(18).string(message.checkType);
    }
    if (message.trigger !== undefined) {
      TaskTrigger.encode(message.trigger, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncTasksResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTasksResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trigger = TaskTrigger.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncTasksResp {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      checkType: isSet(object.checkType) ? globalThis.String(object.checkType) : "",
      trigger: isSet(object.trigger) ? TaskTrigger.fromJSON(object.trigger) : undefined,
    };
  },

  toJSON(message: SyncTasksResp): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.checkType !== "") {
      obj.checkType = message.checkType;
    }
    if (message.trigger !== undefined) {
      obj.trigger = TaskTrigger.toJSON(message.trigger);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncTasksResp>, I>>(base?: I): SyncTasksResp {
    return SyncTasksResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncTasksResp>, I>>(object: I): SyncTasksResp {
    const message = createBaseSyncTasksResp();
    message.id = object.id ?? "";
    message.checkType = object.checkType ?? "";
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? TaskTrigger.fromPartial(object.trigger)
      : undefined;
    return message;
  },
};

function createBaseETHTransfer(): ETHTransfer {
  return { destination: "", amount: "" };
}

export const ETHTransfer: MessageFns<ETHTransfer> = {
  encode(message: ETHTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ETHTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHTransfer {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: ETHTransfer): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ETHTransfer>, I>>(base?: I): ETHTransfer {
    return ETHTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ETHTransfer>, I>>(object: I): ETHTransfer {
    const message = createBaseETHTransfer();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseContractExecution(): ContractExecution {
  return { contractAddress: "", callData: "", method: "", encodedParams: "" };
}

export const ContractExecution: MessageFns<ContractExecution> = {
  encode(message: ContractExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.callData !== "") {
      writer.uint32(18).string(message.callData);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.encodedParams !== "") {
      writer.uint32(34).string(message.encodedParams);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callData = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encodedParams = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractExecution {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      callData: isSet(object.callData) ? globalThis.String(object.callData) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      encodedParams: isSet(object.encodedParams) ? globalThis.String(object.encodedParams) : "",
    };
  },

  toJSON(message: ContractExecution): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.callData !== "") {
      obj.callData = message.callData;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.encodedParams !== "") {
      obj.encodedParams = message.encodedParams;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContractExecution>, I>>(base?: I): ContractExecution {
    return ContractExecution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContractExecution>, I>>(object: I): ContractExecution {
    const message = createBaseContractExecution();
    message.contractAddress = object.contractAddress ?? "";
    message.callData = object.callData ?? "";
    message.method = object.method ?? "";
    message.encodedParams = object.encodedParams ?? "";
    return message;
  },
};

function createBaseGraphQLDataQuery(): GraphQLDataQuery {
  return { url: "", query: "" };
}

export const GraphQLDataQuery: MessageFns<GraphQLDataQuery> = {
  encode(message: GraphQLDataQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphQLDataQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphQLDataQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphQLDataQuery {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: GraphQLDataQuery): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphQLDataQuery>, I>>(base?: I): GraphQLDataQuery {
    return GraphQLDataQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphQLDataQuery>, I>>(object: I): GraphQLDataQuery {
    const message = createBaseGraphQLDataQuery();
    message.url = object.url ?? "";
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseHTTPAPICall(): HTTPAPICall {
  return { url: "", headers: {}, body: "" };
}

export const HTTPAPICall: MessageFns<HTTPAPICall> = {
  encode(message: HTTPAPICall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      HTTPAPICall_HeadersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPAPICall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPAPICall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HTTPAPICall_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.headers[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPAPICall {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? globalThis.String(object.body) : "",
    };
  },

  toJSON(message: HTTPAPICall): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPAPICall>, I>>(base?: I): HTTPAPICall {
    return HTTPAPICall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPAPICall>, I>>(object: I): HTTPAPICall {
    const message = createBaseHTTPAPICall();
    message.url = object.url ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? "";
    return message;
  },
};

function createBaseHTTPAPICall_HeadersEntry(): HTTPAPICall_HeadersEntry {
  return { key: "", value: "" };
}

export const HTTPAPICall_HeadersEntry: MessageFns<HTTPAPICall_HeadersEntry> = {
  encode(message: HTTPAPICall_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPAPICall_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPAPICall_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPAPICall_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTTPAPICall_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTTPAPICall_HeadersEntry>, I>>(base?: I): HTTPAPICall_HeadersEntry {
    return HTTPAPICall_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTTPAPICall_HeadersEntry>, I>>(object: I): HTTPAPICall_HeadersEntry {
    const message = createBaseHTTPAPICall_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomCode(): CustomCode {
  return { type: 0, body: "" };
}

export const CustomCode: MessageFns<CustomCode> = {
  encode(message: CustomCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.body !== "") {
      writer.uint32(18).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomCode {
    return {
      type: isSet(object.type) ? customCodeTypeFromJSON(object.type) : 0,
      body: isSet(object.body) ? globalThis.String(object.body) : "",
    };
  },

  toJSON(message: CustomCode): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = customCodeTypeToJSON(message.type);
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomCode>, I>>(base?: I): CustomCode {
    return CustomCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomCode>, I>>(object: I): CustomCode {
    const message = createBaseCustomCode();
    message.type = object.type ?? 0;
    message.body = object.body ?? "";
    return message;
  },
};

function createBaseConditionJump(): ConditionJump {
  return { expression: "", next: "" };
}

export const ConditionJump: MessageFns<ConditionJump> = {
  encode(message: ConditionJump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.next !== "") {
      writer.uint32(18).string(message.next);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionJump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionJump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.next = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionJump {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      next: isSet(object.next) ? globalThis.String(object.next) : "",
    };
  },

  toJSON(message: ConditionJump): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.next !== "") {
      obj.next = message.next;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConditionJump>, I>>(base?: I): ConditionJump {
    return ConditionJump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConditionJump>, I>>(object: I): ConditionJump {
    const message = createBaseConditionJump();
    message.expression = object.expression ?? "";
    message.next = object.next ?? "";
    return message;
  },
};

function createBaseBranchAction(): BranchAction {
  return { If: undefined, ElseIfs: [], Else: undefined };
}

export const BranchAction: MessageFns<BranchAction> = {
  encode(message: BranchAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.If !== undefined) {
      ConditionJump.encode(message.If, writer.uint32(10).fork()).join();
    }
    for (const v of message.ElseIfs) {
      ConditionJump.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.Else !== undefined) {
      ConditionJump.encode(message.Else, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.If = ConditionJump.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ElseIfs.push(ConditionJump.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Else = ConditionJump.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchAction {
    return {
      If: isSet(object.If) ? ConditionJump.fromJSON(object.If) : undefined,
      ElseIfs: globalThis.Array.isArray(object?.ElseIfs)
        ? object.ElseIfs.map((e: any) => ConditionJump.fromJSON(e))
        : [],
      Else: isSet(object.Else) ? ConditionJump.fromJSON(object.Else) : undefined,
    };
  },

  toJSON(message: BranchAction): unknown {
    const obj: any = {};
    if (message.If !== undefined) {
      obj.If = ConditionJump.toJSON(message.If);
    }
    if (message.ElseIfs?.length) {
      obj.ElseIfs = message.ElseIfs.map((e) => ConditionJump.toJSON(e));
    }
    if (message.Else !== undefined) {
      obj.Else = ConditionJump.toJSON(message.Else);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BranchAction>, I>>(base?: I): BranchAction {
    return BranchAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BranchAction>, I>>(object: I): BranchAction {
    const message = createBaseBranchAction();
    message.If = (object.If !== undefined && object.If !== null) ? ConditionJump.fromPartial(object.If) : undefined;
    message.ElseIfs = object.ElseIfs?.map((e) => ConditionJump.fromPartial(e)) || [];
    message.Else = (object.Else !== undefined && object.Else !== null)
      ? ConditionJump.fromPartial(object.Else)
      : undefined;
    return message;
  },
};

function createBaseTaskAction(): TaskAction {
  return {
    taskType: 0,
    id: "",
    name: "",
    next: [],
    ethTransfer: undefined,
    contractExecution: undefined,
    graphqlDataQuery: undefined,
    httpDataQuery: undefined,
    customCode: undefined,
    branch: undefined,
  };
}

export const TaskAction: MessageFns<TaskAction> = {
  encode(message: TaskAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskType !== 0) {
      writer.uint32(8).int32(message.taskType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.next) {
      writer.uint32(34).string(v!);
    }
    if (message.ethTransfer !== undefined) {
      ETHTransfer.encode(message.ethTransfer, writer.uint32(82).fork()).join();
    }
    if (message.contractExecution !== undefined) {
      ContractExecution.encode(message.contractExecution, writer.uint32(90).fork()).join();
    }
    if (message.graphqlDataQuery !== undefined) {
      GraphQLDataQuery.encode(message.graphqlDataQuery, writer.uint32(98).fork()).join();
    }
    if (message.httpDataQuery !== undefined) {
      HTTPAPICall.encode(message.httpDataQuery, writer.uint32(106).fork()).join();
    }
    if (message.customCode !== undefined) {
      CustomCode.encode(message.customCode, writer.uint32(114).fork()).join();
    }
    if (message.branch !== undefined) {
      BranchAction.encode(message.branch, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.next.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ethTransfer = ETHTransfer.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.contractExecution = ContractExecution.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.graphqlDataQuery = GraphQLDataQuery.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.httpDataQuery = HTTPAPICall.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.customCode = CustomCode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.branch = BranchAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAction {
    return {
      taskType: isSet(object.taskType) ? taskTypeFromJSON(object.taskType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      next: globalThis.Array.isArray(object?.next) ? object.next.map((e: any) => globalThis.String(e)) : [],
      ethTransfer: isSet(object.ethTransfer) ? ETHTransfer.fromJSON(object.ethTransfer) : undefined,
      contractExecution: isSet(object.contractExecution)
        ? ContractExecution.fromJSON(object.contractExecution)
        : undefined,
      graphqlDataQuery: isSet(object.graphqlDataQuery) ? GraphQLDataQuery.fromJSON(object.graphqlDataQuery) : undefined,
      httpDataQuery: isSet(object.httpDataQuery) ? HTTPAPICall.fromJSON(object.httpDataQuery) : undefined,
      customCode: isSet(object.customCode) ? CustomCode.fromJSON(object.customCode) : undefined,
      branch: isSet(object.branch) ? BranchAction.fromJSON(object.branch) : undefined,
    };
  },

  toJSON(message: TaskAction): unknown {
    const obj: any = {};
    if (message.taskType !== 0) {
      obj.taskType = taskTypeToJSON(message.taskType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.next?.length) {
      obj.next = message.next;
    }
    if (message.ethTransfer !== undefined) {
      obj.ethTransfer = ETHTransfer.toJSON(message.ethTransfer);
    }
    if (message.contractExecution !== undefined) {
      obj.contractExecution = ContractExecution.toJSON(message.contractExecution);
    }
    if (message.graphqlDataQuery !== undefined) {
      obj.graphqlDataQuery = GraphQLDataQuery.toJSON(message.graphqlDataQuery);
    }
    if (message.httpDataQuery !== undefined) {
      obj.httpDataQuery = HTTPAPICall.toJSON(message.httpDataQuery);
    }
    if (message.customCode !== undefined) {
      obj.customCode = CustomCode.toJSON(message.customCode);
    }
    if (message.branch !== undefined) {
      obj.branch = BranchAction.toJSON(message.branch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAction>, I>>(base?: I): TaskAction {
    return TaskAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAction>, I>>(object: I): TaskAction {
    const message = createBaseTaskAction();
    message.taskType = object.taskType ?? 0;
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.next = object.next?.map((e) => e) || [];
    message.ethTransfer = (object.ethTransfer !== undefined && object.ethTransfer !== null)
      ? ETHTransfer.fromPartial(object.ethTransfer)
      : undefined;
    message.contractExecution = (object.contractExecution !== undefined && object.contractExecution !== null)
      ? ContractExecution.fromPartial(object.contractExecution)
      : undefined;
    message.graphqlDataQuery = (object.graphqlDataQuery !== undefined && object.graphqlDataQuery !== null)
      ? GraphQLDataQuery.fromPartial(object.graphqlDataQuery)
      : undefined;
    message.httpDataQuery = (object.httpDataQuery !== undefined && object.httpDataQuery !== null)
      ? HTTPAPICall.fromPartial(object.httpDataQuery)
      : undefined;
    message.customCode = (object.customCode !== undefined && object.customCode !== null)
      ? CustomCode.fromPartial(object.customCode)
      : undefined;
    message.branch = (object.branch !== undefined && object.branch !== null)
      ? BranchAction.fromPartial(object.branch)
      : undefined;
    return message;
  },
};

function createBaseExecution(): Execution {
  return { epoch: 0, userOpHash: "", error: "" };
}

export const Execution: MessageFns<Execution> = {
  encode(message: Execution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0) {
      writer.uint32(8).int64(message.epoch);
    }
    if (message.userOpHash !== "") {
      writer.uint32(18).string(message.userOpHash);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Execution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userOpHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Execution {
    return {
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
      userOpHash: isSet(object.userOpHash) ? globalThis.String(object.userOpHash) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: Execution): unknown {
    const obj: any = {};
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    if (message.userOpHash !== "") {
      obj.userOpHash = message.userOpHash;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Execution>, I>>(base?: I): Execution {
    return Execution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Execution>, I>>(object: I): Execution {
    const message = createBaseExecution();
    message.epoch = object.epoch ?? 0;
    message.userOpHash = object.userOpHash ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTask(): Task {
  return {
    id: undefined,
    owner: "",
    smartAccountAddress: "",
    trigger: undefined,
    nodes: [],
    startAt: 0,
    expiredAt: 0,
    memo: "",
    completedAt: 0,
    status: 0,
    repeatable: false,
    executions: [],
  };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      UUID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.smartAccountAddress !== "") {
      writer.uint32(26).string(message.smartAccountAddress);
    }
    if (message.trigger !== undefined) {
      TaskTrigger.encode(message.trigger, writer.uint32(34).fork()).join();
    }
    for (const v of message.nodes) {
      TaskAction.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.startAt !== 0) {
      writer.uint32(48).int64(message.startAt);
    }
    if (message.expiredAt !== 0) {
      writer.uint32(56).int64(message.expiredAt);
    }
    if (message.memo !== "") {
      writer.uint32(66).string(message.memo);
    }
    if (message.completedAt !== 0) {
      writer.uint32(72).int64(message.completedAt);
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.repeatable !== false) {
      writer.uint32(88).bool(message.repeatable);
    }
    for (const v of message.executions) {
      Execution.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = UUID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.smartAccountAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trigger = TaskTrigger.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nodes.push(TaskAction.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiredAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.completedAt = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.repeatable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.executions.push(Execution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? UUID.fromJSON(object.id) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      smartAccountAddress: isSet(object.smartAccountAddress) ? globalThis.String(object.smartAccountAddress) : "",
      trigger: isSet(object.trigger) ? TaskTrigger.fromJSON(object.trigger) : undefined,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => TaskAction.fromJSON(e)) : [],
      startAt: isSet(object.startAt) ? globalThis.Number(object.startAt) : 0,
      expiredAt: isSet(object.expiredAt) ? globalThis.Number(object.expiredAt) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      completedAt: isSet(object.completedAt) ? globalThis.Number(object.completedAt) : 0,
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
      repeatable: isSet(object.repeatable) ? globalThis.Boolean(object.repeatable) : false,
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => Execution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = UUID.toJSON(message.id);
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.smartAccountAddress !== "") {
      obj.smartAccountAddress = message.smartAccountAddress;
    }
    if (message.trigger !== undefined) {
      obj.trigger = TaskTrigger.toJSON(message.trigger);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => TaskAction.toJSON(e));
    }
    if (message.startAt !== 0) {
      obj.startAt = Math.round(message.startAt);
    }
    if (message.expiredAt !== 0) {
      obj.expiredAt = Math.round(message.expiredAt);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.completedAt !== 0) {
      obj.completedAt = Math.round(message.completedAt);
    }
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    if (message.repeatable !== false) {
      obj.repeatable = message.repeatable;
    }
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => Execution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.id = (object.id !== undefined && object.id !== null) ? UUID.fromPartial(object.id) : undefined;
    message.owner = object.owner ?? "";
    message.smartAccountAddress = object.smartAccountAddress ?? "";
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? TaskTrigger.fromPartial(object.trigger)
      : undefined;
    message.nodes = object.nodes?.map((e) => TaskAction.fromPartial(e)) || [];
    message.startAt = object.startAt ?? 0;
    message.expiredAt = object.expiredAt ?? 0;
    message.memo = object.memo ?? "";
    message.completedAt = object.completedAt ?? 0;
    message.status = object.status ?? 0;
    message.repeatable = object.repeatable ?? false;
    message.executions = object.executions?.map((e) => Execution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTaskReq(): CreateTaskReq {
  return { trigger: undefined, actions: [], startAt: 0, expiredAt: 0, memo: "", repeatable: false };
}

export const CreateTaskReq: MessageFns<CreateTaskReq> = {
  encode(message: CreateTaskReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trigger !== undefined) {
      TaskTrigger.encode(message.trigger, writer.uint32(10).fork()).join();
    }
    for (const v of message.actions) {
      TaskAction.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.startAt !== 0) {
      writer.uint32(24).int64(message.startAt);
    }
    if (message.expiredAt !== 0) {
      writer.uint32(32).int64(message.expiredAt);
    }
    if (message.memo !== "") {
      writer.uint32(42).string(message.memo);
    }
    if (message.repeatable !== false) {
      writer.uint32(48).bool(message.repeatable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trigger = TaskTrigger.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actions.push(TaskAction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startAt = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiredAt = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.repeatable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskReq {
    return {
      trigger: isSet(object.trigger) ? TaskTrigger.fromJSON(object.trigger) : undefined,
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => TaskAction.fromJSON(e)) : [],
      startAt: isSet(object.startAt) ? globalThis.Number(object.startAt) : 0,
      expiredAt: isSet(object.expiredAt) ? globalThis.Number(object.expiredAt) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      repeatable: isSet(object.repeatable) ? globalThis.Boolean(object.repeatable) : false,
    };
  },

  toJSON(message: CreateTaskReq): unknown {
    const obj: any = {};
    if (message.trigger !== undefined) {
      obj.trigger = TaskTrigger.toJSON(message.trigger);
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => TaskAction.toJSON(e));
    }
    if (message.startAt !== 0) {
      obj.startAt = Math.round(message.startAt);
    }
    if (message.expiredAt !== 0) {
      obj.expiredAt = Math.round(message.expiredAt);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.repeatable !== false) {
      obj.repeatable = message.repeatable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTaskReq>, I>>(base?: I): CreateTaskReq {
    return CreateTaskReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTaskReq>, I>>(object: I): CreateTaskReq {
    const message = createBaseCreateTaskReq();
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? TaskTrigger.fromPartial(object.trigger)
      : undefined;
    message.actions = object.actions?.map((e) => TaskAction.fromPartial(e)) || [];
    message.startAt = object.startAt ?? 0;
    message.expiredAt = object.expiredAt ?? 0;
    message.memo = object.memo ?? "";
    message.repeatable = object.repeatable ?? false;
    return message;
  },
};

function createBaseCreateTaskResp(): CreateTaskResp {
  return { id: "" };
}

export const CreateTaskResp: MessageFns<CreateTaskResp> = {
  encode(message: CreateTaskResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskResp {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: CreateTaskResp): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTaskResp>, I>>(base?: I): CreateTaskResp {
    return CreateTaskResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTaskResp>, I>>(object: I): CreateTaskResp {
    const message = createBaseCreateTaskResp();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNonceRequest(): NonceRequest {
  return { owner: "" };
}

export const NonceRequest: MessageFns<NonceRequest> = {
  encode(message: NonceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonceRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: NonceRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NonceRequest>, I>>(base?: I): NonceRequest {
    return NonceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NonceRequest>, I>>(object: I): NonceRequest {
    const message = createBaseNonceRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseNonceResp(): NonceResp {
  return { nonce: "" };
}

export const NonceResp: MessageFns<NonceResp> = {
  encode(message: NonceResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce !== "") {
      writer.uint32(10).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonceResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonceResp {
    return { nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "" };
  },

  toJSON(message: NonceResp): unknown {
    const obj: any = {};
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NonceResp>, I>>(base?: I): NonceResp {
    return NonceResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NonceResp>, I>>(object: I): NonceResp {
    const message = createBaseNonceResp();
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseAddressRequest(): AddressRequest {
  return { owner: "" };
}

export const AddressRequest: MessageFns<AddressRequest> = {
  encode(message: AddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: AddressRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressRequest>, I>>(base?: I): AddressRequest {
    return AddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressRequest>, I>>(object: I): AddressRequest {
    const message = createBaseAddressRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseAddressResp(): AddressResp {
  return { smartAccountAddress: "", nonce: "" };
}

export const AddressResp: MessageFns<AddressResp> = {
  encode(message: AddressResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.smartAccountAddress !== "") {
      writer.uint32(10).string(message.smartAccountAddress);
    }
    if (message.nonce !== "") {
      writer.uint32(18).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.smartAccountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressResp {
    return {
      smartAccountAddress: isSet(object.smartAccountAddress) ? globalThis.String(object.smartAccountAddress) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: AddressResp): unknown {
    const obj: any = {};
    if (message.smartAccountAddress !== "") {
      obj.smartAccountAddress = message.smartAccountAddress;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressResp>, I>>(base?: I): AddressResp {
    return AddressResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressResp>, I>>(object: I): AddressResp {
    const message = createBaseAddressResp();
    message.smartAccountAddress = object.smartAccountAddress ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseListTasksReq(): ListTasksReq {
  return {};
}

export const ListTasksReq: MessageFns<ListTasksReq> = {
  encode(_: ListTasksReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListTasksReq {
    return {};
  },

  toJSON(_: ListTasksReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksReq>, I>>(base?: I): ListTasksReq {
    return ListTasksReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksReq>, I>>(_: I): ListTasksReq {
    const message = createBaseListTasksReq();
    return message;
  },
};

function createBaseListTasksResp(): ListTasksResp {
  return { tasks: [] };
}

export const ListTasksResp: MessageFns<ListTasksResp> = {
  encode(message: ListTasksResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tasks) {
      ListTasksResp_TaskItemResp.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tasks.push(ListTasksResp_TaskItemResp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksResp {
    return {
      tasks: globalThis.Array.isArray(object?.tasks)
        ? object.tasks.map((e: any) => ListTasksResp_TaskItemResp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListTasksResp): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => ListTasksResp_TaskItemResp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksResp>, I>>(base?: I): ListTasksResp {
    return ListTasksResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksResp>, I>>(object: I): ListTasksResp {
    const message = createBaseListTasksResp();
    message.tasks = object.tasks?.map((e) => ListTasksResp_TaskItemResp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListTasksResp_TaskItemResp(): ListTasksResp_TaskItemResp {
  return { id: "", status: 0 };
}

export const ListTasksResp_TaskItemResp: MessageFns<ListTasksResp_TaskItemResp> = {
  encode(message: ListTasksResp_TaskItemResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksResp_TaskItemResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksResp_TaskItemResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksResp_TaskItemResp {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ListTasksResp_TaskItemResp): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksResp_TaskItemResp>, I>>(base?: I): ListTasksResp_TaskItemResp {
    return ListTasksResp_TaskItemResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksResp_TaskItemResp>, I>>(object: I): ListTasksResp_TaskItemResp {
    const message = createBaseListTasksResp_TaskItemResp();
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetKeyReq(): GetKeyReq {
  return { owner: "", expiredAt: 0, signature: "" };
}

export const GetKeyReq: MessageFns<GetKeyReq> = {
  encode(message: GetKeyReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.expiredAt !== 0) {
      writer.uint32(16).int64(message.expiredAt);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiredAt = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyReq {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      expiredAt: isSet(object.expiredAt) ? globalThis.Number(object.expiredAt) : 0,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: GetKeyReq): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.expiredAt !== 0) {
      obj.expiredAt = Math.round(message.expiredAt);
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyReq>, I>>(base?: I): GetKeyReq {
    return GetKeyReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyReq>, I>>(object: I): GetKeyReq {
    const message = createBaseGetKeyReq();
    message.owner = object.owner ?? "";
    message.expiredAt = object.expiredAt ?? 0;
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseKeyResp(): KeyResp {
  return { key: "" };
}

export const KeyResp: MessageFns<KeyResp> = {
  encode(message: KeyResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyResp {
    return { key: isSet(object.key) ? globalThis.String(object.key) : "" };
  },

  toJSON(message: KeyResp): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyResp>, I>>(base?: I): KeyResp {
    return KeyResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyResp>, I>>(object: I): KeyResp {
    const message = createBaseKeyResp();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseUpdateChecksReq(): UpdateChecksReq {
  return { address: "", signature: "", id: [] };
}

export const UpdateChecksReq: MessageFns<UpdateChecksReq> = {
  encode(message: UpdateChecksReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    for (const v of message.id) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChecksReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChecksReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChecksReq {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UpdateChecksReq): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.id?.length) {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateChecksReq>, I>>(base?: I): UpdateChecksReq {
    return UpdateChecksReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateChecksReq>, I>>(object: I): UpdateChecksReq {
    const message = createBaseUpdateChecksReq();
    message.address = object.address ?? "";
    message.signature = object.signature ?? "";
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateChecksResp(): UpdateChecksResp {
  return { updatedAt: undefined };
}

export const UpdateChecksResp: MessageFns<UpdateChecksResp> = {
  encode(message: UpdateChecksResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChecksResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChecksResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChecksResp {
    return { updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined };
  },

  toJSON(message: UpdateChecksResp): unknown {
    const obj: any = {};
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateChecksResp>, I>>(base?: I): UpdateChecksResp {
    return UpdateChecksResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateChecksResp>, I>>(object: I): UpdateChecksResp {
    const message = createBaseUpdateChecksResp();
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

export interface Aggregator {
  /** Auth */
  GetKey(request: GetKeyReq): Promise<KeyResp>;
  /** Smart Acccount */
  GetNonce(request: NonceRequest): Promise<NonceResp>;
  GetSmartAccountAddress(request: AddressRequest): Promise<AddressResp>;
  /** Task Management */
  CreateTask(request: CreateTaskReq): Promise<CreateTaskResp>;
  ListTasks(request: ListTasksReq): Promise<ListTasksResp>;
  GetTask(request: UUID): Promise<Task>;
  CancelTask(request: UUID): Promise<BoolValue>;
  DeleteTask(request: UUID): Promise<BoolValue>;
  /** Operator endpoint */
  Ping(request: Checkin): Promise<CheckinResp>;
  SyncTasks(request: SyncTasksReq): Observable<SyncTasksResp>;
  UpdateChecks(request: UpdateChecksReq): Promise<UpdateChecksResp>;
}

export const AggregatorServiceName = "aggregator.Aggregator";
export class AggregatorClientImpl implements Aggregator {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AggregatorServiceName;
    this.rpc = rpc;
    this.GetKey = this.GetKey.bind(this);
    this.GetNonce = this.GetNonce.bind(this);
    this.GetSmartAccountAddress = this.GetSmartAccountAddress.bind(this);
    this.CreateTask = this.CreateTask.bind(this);
    this.ListTasks = this.ListTasks.bind(this);
    this.GetTask = this.GetTask.bind(this);
    this.CancelTask = this.CancelTask.bind(this);
    this.DeleteTask = this.DeleteTask.bind(this);
    this.Ping = this.Ping.bind(this);
    this.SyncTasks = this.SyncTasks.bind(this);
    this.UpdateChecks = this.UpdateChecks.bind(this);
  }
  GetKey(request: GetKeyReq): Promise<KeyResp> {
    const data = GetKeyReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetKey", data);
    return promise.then((data) => KeyResp.decode(new BinaryReader(data)));
  }

  GetNonce(request: NonceRequest): Promise<NonceResp> {
    const data = NonceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNonce", data);
    return promise.then((data) => NonceResp.decode(new BinaryReader(data)));
  }

  GetSmartAccountAddress(request: AddressRequest): Promise<AddressResp> {
    const data = AddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSmartAccountAddress", data);
    return promise.then((data) => AddressResp.decode(new BinaryReader(data)));
  }

  CreateTask(request: CreateTaskReq): Promise<CreateTaskResp> {
    const data = CreateTaskReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateTask", data);
    return promise.then((data) => CreateTaskResp.decode(new BinaryReader(data)));
  }

  ListTasks(request: ListTasksReq): Promise<ListTasksResp> {
    const data = ListTasksReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListTasks", data);
    return promise.then((data) => ListTasksResp.decode(new BinaryReader(data)));
  }

  GetTask(request: UUID): Promise<Task> {
    const data = UUID.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTask", data);
    return promise.then((data) => Task.decode(new BinaryReader(data)));
  }

  CancelTask(request: UUID): Promise<BoolValue> {
    const data = UUID.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelTask", data);
    return promise.then((data) => BoolValue.decode(new BinaryReader(data)));
  }

  DeleteTask(request: UUID): Promise<BoolValue> {
    const data = UUID.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteTask", data);
    return promise.then((data) => BoolValue.decode(new BinaryReader(data)));
  }

  Ping(request: Checkin): Promise<CheckinResp> {
    const data = Checkin.encode(request).finish();
    const promise = this.rpc.request(this.service, "Ping", data);
    return promise.then((data) => CheckinResp.decode(new BinaryReader(data)));
  }

  SyncTasks(request: SyncTasksReq): Observable<SyncTasksResp> {
    const data = SyncTasksReq.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SyncTasks", data);
    return result.pipe(map((data) => SyncTasksResp.decode(new BinaryReader(data))));
  }

  UpdateChecks(request: UpdateChecksReq): Promise<UpdateChecksResp> {
    const data = UpdateChecksReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateChecks", data);
    return promise.then((data) => UpdateChecksResp.decode(new BinaryReader(data)));
  }
}

export interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
